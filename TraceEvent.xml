<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TraceEvent</name>
    </assembly>
    <members>
        <member name="T:Diagnostics.Tracing.TraceEventParser">
            <summary>
            code:TraceEventParser Represents a class that knows how to decode particular set of events (typcially
            grouped by provider). It is the embodyment of all the type information that is typically stored in a
            ETW MOF file (Windows XP events) or an ETW manifest (Vista events). It is expected that a
            TraceEventParser can be generated completely mechanically from a MOF or ETW manifest (it really is
            just a decoder of that type information).
            
            There is no static interface associated with a TraceEventParser, but there is a dynamic one. It is
            expected that TraceEventsParsers have a set of public event APIs of the form
            
                public event Action[SubclassOfTraceEvent] EventName
            
            which allows users of the parser to subscribe to callbacks (in the case about called 'EventName'. The
            callback take a single argument (in this case SubclassOfTraceEvent) which is passed to the callback.
            
            TraceEventParsers typically are constructed with a constructor that takes a code:TraceEventSource.
            The parser remembers the source, and when users subscribe to events on the code:TraceEventParser, the
            parser in turn calls code:TraceEventSource.RegisterEventTemplate with the correct subclass of
            code:TraceEvent that knows how to decode all the fields a a paraticular event.
            
            Thus a code:TraceEventParser has built int support for a 'callback' model for subscribing to events.
            Parsers also support interacting with sources that support an iterator model. The code:TraceLog class
            is an example of this. In this model the user still 'registers' a parser with the source. When this
            registration happens, the source in turn calls back to the code:TraceEventParser.All event on the
            parser registering a 'null' callback. This causes the parser to register all events with the source
            with null callbacks. The callbacks are are never used (afer all, they are null), but the source
            needed the templates to be registered so the event payload data can be decoded.
            
            * See code:ClrTraceEventParser
            * See code:KernelTraceEventParser
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventParser.AddToAllMatching``1(System.Action{``0})">
            <summary>
            Subscribe to all events compatible with 'callback' 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventParser.source">
            <summary>
            The source that this parser is connected to.  
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.TraceEventParser.All">
            <summary>
            Subscribe to all the events this parser can parse.  Note that it will only add to
            events that are compatible with the delegate that is passed.  This is useful because
            it allows you to match all events that a certain delegate understands.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEvent">
             <summary>
             code:TraceEvent represents the data from one event. Logically a TraceEventSource is mostly just a
             stream of TraceEvent objects. An event is identified by a GUID (128 bit unique ID) of the event
             provider that generated it PLUS a small integer (must fit in a ushort) code:TraceEventID that
             distinguishes it among other events from the same provider.
             
             The provider GUID and the Event ID together uniquely identify the data format of the event. Event
             providers can provide a description of events and their payloads in a manifest that is traditionally
             defined by an XML file (in Windows Vista). For Pre-vista ETW, the descriptions are done with MOF
             files. There are tools that can convert a XML manifest description to C# that defines a
             code:TraceEventParser which can be used by this infrastructure.
            
             There are operations (Start, Stop), that are common to a broad set of differnet events (from
             different providers), that should be processed in simmiar ways. To make identifing these common kinds
             of events easier, events can be given an code:TraceEventOpcode which indentified these common
             patterns.
            
             While Event data can have arbitrary data in it, there is a header that every event must have.
             TraceEvent provides an interface to this header data and other operations that can be done without
             needing to know that exact layout of the event data. In particular every event knows its Provider
             GUID (but not necessarily its name), opcode number (but not necessarily its opocode name), the time
             it happened, the code:TraceEventLevel (how important the event is) the thread it happened on (not all
             events have an associated thread), and the size of the event-specific data.
             
             The basic architecture is that specific events (eg. the 'Process' event with opcode 'Start') define a
             new subclass of code:TraceEvent (eg. code:ProcessTraceData) that define properties that know how to
             parse the raw data into its various 'fields'.
             
             In addition a code:TraceEvent instance has support for the subscription model in the form a a the
             code:TraceEvent.Dispatch virtual function. Events can remember a user-defined callback and dispatch
             to that callback when the Dispatch' virtual methodIndex is called.
             
             An important restriction is that a TraceEvent becomes invalid after the callback is complete (it is
             reused for the next event of that type in the stream). Thus callers should NOT cache instances of the
             subclass of TraceEvent in their own data structures, but copy out the data they need or call
             code:TraceEvent.Clone if they need a permanent copy.
             </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.EventData">
            <summary>
            Returns an array of bytes reprsenting the Event-specific payload associted with the event.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.EventData(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the event data and puts it in 'targetBuffer' at 'targetStartIndex' and returns the resulting buffer.
            If 'targetBuffer is null, it will allocate a buffer of the correct size.  Note that normally you
            don't need to use this routine as some subclass of EventData that does proper parsing will work
            for you instead.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Clone">
            <summary>
            The events passed to the callback functions only last as long as the callback, so if you need to
            keep the information around after that you need to copy it.  If it is convinient to store it as
            the original event, you can do so using this Clone functionality.  Note that this operation is
            not really cheap, so you should avoid calling it if you can. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.ToString">
            <summary>
            Pretty print the event.  It uses XML syntax so you can make XML with this routine too. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Dump">
            <summary>
            Dumps a very verbose description of the event, including a dump of they payload bytes. It is in
            XML format. This is very useful in debugging (put it in a watch window) when parsers are not
            interpreting payloads properly.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.PayloadValue(System.Int32)">
            <summary>
            Given an index from 0 to PayloadNames.Length-1, return the value for that payload item
            as an object (boxed if necessary).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.PayloadString(System.Int32)">
            <summary>
            PayloadString is like PayloadValue(index).ToString(), however it allows the subclasses to do a better
            job of doing a toString (in particular using symbolic names for enumerations.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.PayloadByName(System.String)">
            <summary>
            Only use this if you don't care about performance.  It fetches a field by name.  Will return
            null if the name is not found.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Compare(Diagnostics.Tracing.EventIndex,Diagnostics.Tracing.EventIndex)">
            <summary>
            Used for binary searching of event IDs.    Abstracts the size (currently a int, could go to long) 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            A standard way for events to are that certain addresses are addresses in code and ideally have
            symbolic information associated with them.  Returns true if successful.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.SkipUTF8String(System.Int32)">
            <summary>
            Assume that  'Offset' bytes into the 'mofData' is a ascii 
            string.  Return the Offset after it is skipped.  This is intended
            to be used by subclasses trying to parse mofData 
            </summary>
            <param name="offset">the starting Offset</param>
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.SkipUnicodeString(System.Int32)">
            <summary>
            Assume that  'offset' bytes into the 'mofData' is a unicode 
            string.  Return the Offset after it is skipped.  This is intended
            to be used by subclasses trying to parse mofData 
            </summary>
            <param name="offset">the starting Offset</param>
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.SkipSID(System.Int32)">
            <summary>
            Assume that  'offset' bytes into the 'mofData' is SID.
            Return the Offset after it is skipped.  This is intended
            to be used by subclasses trying to parse mofData 
            </summary>
            <param name="offset">the starting Offset</param>
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.HostOffset(System.Int32,System.Int32)">
            <summary>
            Trivial helper that allows you to get the Offset of a field independent of 32 vs 64 bit pointer
            size.
            </summary>
            <param name="offset">The Offset as it would be on a 32 bit system</param>
            <param name="numPointers">The number of pointer-sized fields that came before this field.
            </param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.GetUTF8StringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated ASCII string in an event blob, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.GetFixedUnicodeStringAt(System.Int32,System.Int32)">
            <summary>
            Given an Offset to a fixed sized string at 'offset', whose buffer size is 'charCount'
            return the string value.  A null in the string will terminate the string before the
            end of the buffer. 
            </summary>        
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.GetUnicodeStringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated unicode string in an event blob, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.GetIntPtrAt(System.Int32)">
            <summary>
            Get something that is machine word sized for the provider that collected the data, but is an
            integer (and not an address)
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.GetHostPointer(System.Int32)">
            <summary>
            Gets something that is pointer sized for the provider that collected the data.  
            TODO rename to GetPointerAt()
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Prefix(System.Text.StringBuilder)">
            <summary>
            Prints a standard prefix for a event (includes the time of the event, the process ID and the
            thread ID.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.EventDataAsString">
            <summary>
             If the event data looks like a unicode string, then return it.  This is heuristic.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Dispatch">
            <summary>
            Each code:TraceEvent items knows where it should Dispatch to.
            code:ETWTraceEventSource.Dispatch calls this function to go to the right placed. By default we
            do nothing. Typically a subclass just dispatches to another callback that passes itself to a
            type-specific event callback.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvent.Validate">
            <summary>
            This is a DEBUG-ONLY routine that allows a routine to do consistancy checking in a debug build.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEvent.next">
            <summary>
            TraceEvent knows where to dispatch to. To support many subscriptions to the same event we chain
            them.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ProviderGuid">
            <summary>
            The GUID that uniquely identifies the Provider for this event.  This can return Guid.Empty for
            pre-VISTA ETW providers.  
            </summary>        
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.EventName">
            <summary>
            A name for the event.  This is simply the concatination of the task and opcode names. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ID">
            <summary>
            Returns the provider-specific integer value that uniquely identifies event within the scope of
            the provider. (Currently returns 0 for pre-VISTA ETW providers).
            
            The strong convention (but is is only a convention) is that every (Task x Opcode) pair is given
            a unique ID.   
            
            TODO: Synthesize something for pre-Vista?
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Task">
            <summary>
            Events for a given provider can be given a group identifier called a Task that indicates the
            broad area within the provider that the event pertains to (for example the Kernel provider has
            Tasks for Process, Threads, etc).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.TaskName">
            <summary>
            The human readable name for the event's task (group of related events) (eg. process, thread,
            image, GC, ...).  May return a string Task(GUID) or Task(TASK_NUM) if no good symbolic name is
            available. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Opcode">
            <summary>
            Each event has a Type identifier that indicates what kind of an event is being logged. Note that
            providers are free to extend this set, so the id may not be just the value in code:TraceEventOpcode
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.OpcodeName">
            <summary>
            Returns the human-readable string name for the code:Opcode property. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Level">
            <summary>
            The verbosity of the event (Fatal, Error, ..., Info, Verbose)
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Version">
            <summary>
            The version number for this event.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Keyword">
            <summary>
            When an entry is logged it can specify a bitfield TraceEventKeyword that identifies
            provider-specific 'areas' that the event is relevent to.  Return this bitfield for the event. 
            Returns TraceEventKeyword.None for pre-VISTA ETW providers. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Channel">
            <summary>
            A Channel is a provider defined 'audience' for the event.  It is TraceEventChannel.Default for
            Pre-Vista providers.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ThreadID">
            <summary>
            The thread ID for the event
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ProcessID">
            <summary>
            The process ID of the process which caused the event. 
            
            Note that this field may return -1 for some events (which don't log a process ID but only a Thread ID, 
            like sampled Profile events) if you have lost thread start events (e.g. Circular buffering) and have not 
            scanned the data once (so we see the rundown events).    
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.TimeStamp100ns">
            <summary>
            The time of the event, represented in 100ns units from the year 1601.  See also code:TimeDateStamp
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.TimeStamp">
            <summary>
            The time of the event. The overhead of creating a DateTime object can be avoided using
            code:TimeStamp100ns
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ProcessName">
            <summary>
            Returns a short name for the process. This the image file name (without the path or extension),
            or if that is not present, then the string "(" ProcessID + ")" 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.TimeStampRelativeMSec">
            <summary>
            Returns a double representing the number of milliseconds since the beining of the trace.     
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ProcessorNumber">
            <summary>
            The processor Number (from 0 to code:TraceEventSource.NumberOfProcessors) that generated this
            event. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.PointerSize">
            <summary>
            Get the size of a pointer associated with the event.  
            This can be used to determine if the process is 32 (in the WOW) or 64 bit.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.EventIndex">
            <summary>
            An EventIndex is a integer that is guarenteed to be unique for this even over the entire log.  Its
            primary purpose is to act as a key that allows side tables to be built up that allow value added
            processing to 'attach' additional data to this particular event unambiguously.  
            
            EventIndex is currently a 4 byte quantity.  This does limit log sizes to 4Gig of events, but
            that is a LOT of events.  (realistically > 100 GIG ETL files)   
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.Source">
            <summary>
            The TraceEventSource associated with this event
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.RelatedActivityID">
            <summary>
            Returns the RelatedActivityID associted with the event or Guid.Empty if none. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.EventDataLength">
            <summary>
            The size of the Event-specific data payload.  (see code:EventData)
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.PayloadNames">
            <summary>
            returns the names of all the manifest declared field names for the event.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.FormattedMessage">
            <summary>
            Return a formatted string for the entire event, fit for human consumption.   It will return null if the event does not 
            define a 'message' string that defines the formatting.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.ClassicProvider">
            <summary>
            Is this a Pre-Vista (classic) provider?
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.StringOnly">
            <summary>
            Was this written with WriteMessage?
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvent.DataStart">
            <summary>
            Returns the raw IntPtr pointer to the data blob associated with the event.  This is the way the
            subclasses of TraceEvent get at the data to display it in a reasonable fashion.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.Gens">
            <summary>
            We keep Heap history for every Generation in 'Gens' 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.GCPerHeapHistoryTraceData">
            <summary>
            This structure is in the ndp\clr\src\vm\gcrecord.h file. 
            The easiest way to get th layout is to do a 'dt' command on the structure (use x command to search)
            
            The method that writes it is Etw_GCDataPerHeapSpecial.  Look that up in the debugger and go to source
            to open gcrecord.h.   The interesting data structures are 
            
            dt WKS::gc_generation_data 
            dt WKS::gc_history_per_heap
            
            For Silverlight (X86) 
            
            0:014> dt coreclr!WKS::gc_history_per_heap
               +0x000 gen_data         : [5] WKS::gc_generation_data
               +0x0c8 mem_pressure     : Uint4B
               +0x0cc mechanisms       : [2] Uint4B
               +0x0d4 gen_condemn_reasons : Uint4B
               +0x0d8 heap_index       : Uint4B
            0:014> dt coreclr!WKS::gc_generation_data
               +0x000 size_before      : Uint4B
               +0x004 size_after       : Uint4B
               +0x008 current_size     : Uint4B
               +0x00c previous_size    : Uint4B
               +0x010 fragmentation    : Uint4B
               +0x014 in               : Uint4B
               +0x018 out              : Uint4B
               +0x01c new_allocation   : Uint4B
               +0x020 surv             : Uint4B
               +0x024 growth           : Uint4B
             
            For 4.5 (X86)
            0:000> dt clr!WKS::gc_history_per_heap
               +0x000 gen_data         : [5] WKS::gc_generation_data
               +0x0c8 gen_to_condemn_reasons : WKS::gen_to_condemn_tuning
               +0x0d0 mem_pressure     : Uint4B
               +0x0d4 mechanisms       : [2] Uint4B
               +0x0dc heap_index       : Uint4B
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.GCPerHeapHistoryTraceData.GenData(Diagnostics.Tracing.Parsers.Gens)">
            <summary>
            genNumber is a number from 0 to maxGenData-1.  These are for generation 0, 1, 2, 3 = Large Object Heap
            genNumber = 4 is that second pass for Gen 0.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.SizeBefore">
            <summary>
            Size of the generation before the GC, includes fragmentation
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.SizeAfter">
            <summary>
            Size of the generation after GC.  Includes fragmentation
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.ObjSpaceBefore">
            <summary>
            Size occupied by objects at the beginning of the GC, discounting fragmentation. 
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.Fragmentation">
            <summary>
            This is the fragmenation at the end of the GC.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.ObjSizeAfter">
            <summary>
            Size occupied by objects, discounting fragmentation.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.FreeListSpaceBefore">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.FreeObjSpaceBefore">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.FreeListSpaceAfter">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.FreeObjSpaceAfter">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.In">
            <summary>
            This is the amount that came into this generation on this GC
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.Out">
            <summary>
            This is the number of bytes leaving this generation (it is a synonym for promoted). 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.Budget">
            <summary>
            This is the new budget for the generation
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.GCPerHeapHistoryGenData.SurvRate">
            <summary>
            This is the survival rate
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords">
            <summary>
             Keywords are passed to code:TraceEventSession.EnableProvider to enable particular sets of
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GC">
            <summary>
            Logging when garbage collections and finalization happen. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Loader">
            <summary>
            Logging when modules actually get loaded and unloaded. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Jit">
            <summary>
            Logging when Just in time (JIT) compilation occurs. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.NGen">
            <summary>
            Logging when precompiled native (NGEN) images are loaded.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StartEnumeration">
            <summary>
            Indicates that on attach or module load , a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StopEnumeration">
            <summary>
            Indicates that on detach or process shutdown, a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Security">
            <summary>
            Events associted with validating security restrictions.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.AppDomainResourceManagement">
            <summary>
            Events for logging resource consumption on an app-domain level granularity
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JitTracing">
            <summary>
            Logging of the internal workings of the Just In Time compiler.  This is fairly verbose.  
            It details decidions about interesting optimization (like inlining and tail call) 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Interop">
            <summary>
            Log information about code thunks that transition between managed and unmanaged code. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Contention">
            <summary>
            Log when lock conentions occurs.  (Monitor.Enters actually blocks)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Exception">
            <summary>
            Log exception processing.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.SupressNGen">
            <summary>
            This supresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Stack">
            <summary>
            Also log the stack trace of events for which this is valuable.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Default">
            <summary>
            Recommend default flags (good compromise on verbosity).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ClrStackWalkTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="i">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.ClrStackWalkTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.ModuleLoadUnloadTraceData.ModuleILFileName">
            <summary>
            This is simply the file name part of the ModuleILPath.  It is a convinience method. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrRundownTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrRundownTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrRundownTraceEventParser.Keywords.SupressNGen">
            <summary>
            This supresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.ClrRundownTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="T:Symbols.SymbolReader">
            <summary>
            A symbol reader represents something that can FIND pdbs (either on a symbol server or via a symbol path)
            Its job is to find a full path a PDB.  Then you can use OpenSymbolFile to get a SymbolReaderModule and do more. 
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Opens a new SymbolReader.   All diagnostics messages about symbol lookup go to 'log'.  
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.FindSymbolFilePathForModule(System.String)">
            <summary>
            Finds the symbol file for 'exeFilePath' that exists on the current machine (we open
            it to find the needed info).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.  
            
            This routine looks in the EXEFile to find the PDB Guid signature and then calls FindSymbolFilePath
            
            returns null if the pdb can't be found.  
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.FindSymbolFilePath(System.String,System.Guid,System.Int32,System.String,System.String)">
            <summary>
            Find the complete PDB path, given just the simple name (filename + pdb extension) as well as its 'signature', 
            which uniquely identifies it (on symbol servers).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.  
            
            A Guid of 0, means 'unknown' and will match the first PDB that matches simple name.  Thus it is unsafe. 
            
            Returns null if the PDB could  not be found
            
            </summary>
            <param name="pdbSimpleName">The name of the PDB file (we only use the file name part)</param>
            <param name="pdbIndexGuid">The GUID that is embedded in the DLL in the debug information that allows matching the DLL and the PDB</param>
            <param name="pdbIndexAge">Tools like BBT transform a DLL into another DLL (with the same GUID) the 'pdbAge' is a small integers
            that indicates how many transformations were done</param>
            <param name="dllFilePath">If you know the path to the DLL for this pdb add it here.  That way we can probe next to the DLL
            for the PDB file.</param>
            <param name="fileVersion">This is an optional string that identifies the file version (the 'Version' resource information.  
            It is used only to provided better error messages for the log.</param>
        </member>
        <member name="M:Symbols.SymbolReader.OpenSymbolFile(System.String)">
            <summary>
            Given the path name to a particular PDB file, load it so that you can resolve symbols in it.  
            </summary>
            <param name="symbolFilePath">The name of the PDB file to open.</param>
            <returns>The SymbolReaderModule that represents the information in the symbol file (PDB)</returns>
        </member>
        <member name="F:Symbols.SymbolReader.CacheUnsafePdbs">
            <summary>
            Cache even the unsafe pdbs to the SymbolCacheDirectory.   TODO: is this a hack?
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.Dispose">
            <summary>
            Note that all SymbolReaderModules returned by 'OpenSymbolFile' become invalid after disposing of the SymbolReader.  
            </summary>
            
        </member>
        <member name="M:Symbols.SymbolReader.GetPhysicalFileFromServer(System.String,System.String,System.String)">
            <summary>
            Fetches a file from the server 'serverPath' weith pdb signature path 'pdbSigPath' and places it in its
            correct location in 'symbolCacheDir'  Will return the path of the cached copy if it succeeds, null otherwise.  
            
            You should probably be using GetFileFromServer
            </summary>
            <param name="serverPath">path to server (eg. \\symbols\symbols or http://symweb) </param>
            <param name="pdbIndexPath">pdb path with signature (e.g clr.pdb/1E18F3E494DC464B943EA90F23E256432/clr.pdb)</param>
            <param name="symbolCacheDir">path to the symbol cache where files are fetched (e.g. %TEMP%\symbols) </param>
        </member>
        <member name="M:Symbols.SymbolReader.CopyStreamToFile(System.IO.Stream,System.String,System.String)">
            <summary>
            This just copies a stream to a file path with logging.  
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.FindExecutableFilePath(System.String,System.Int32,System.Int32)">
            <summary>
            This API looks up an executable file, by its build-timestamp and size (on a symbol server),  'fileName' should be 
            a simple name (no directory), and you need the buildTimeStamp and sizeOfImage that are found in the PE header.
            
            Returns null if it cannot find anything.  
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.GetFileFromServer(System.String,System.String,System.String)">
            <summary>
            Looks up 'fileIndexPath' on the server 'urlForServer' copying the file to 'symbolCacheDir' and returning the
            path name there (thus it is always a local file).  Unlike  GetPhysicalFileFromServer, GetFileFromServer understands
            how to deal with compressed files and file.ptr (redirection).  
            </summary>
            <returns>The path to a local file or null if the file cannot be found.</returns>
        </member>
        <member name="M:Symbols.SymbolReader.CacheFileLocally(System.String,System.Guid,System.Int32)">
            <summary>
            This is an optional routine.  It is already the case that if you find a PDB on a symbol server
            that it will be cached locally, however if you find it on a network path by NOT using a symbol
            server, it will be used in place.  This is annoying, and this routine makes up for this by
            mimicking this behavior.  Basically if pdbPath is not a local file name, it will copy it to
            the local symbol cache and return the local path. 
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.BypassSystem32FileRedirection(System.String)">
            <summary>
            We may be a 32 bit app which has File system redirection turned on
            Morph System32 to SysNative in that case to bypass file system redirection         
            </summary>
        </member>
        <member name="M:Symbols.SymbolReader.FindPrivateBuildPdbSearchPath(System.String,System.String)">
            <summary>
            This function is useful only internally in Microsoft.  It is useful for builds that are not 
            published on the symbol server.   It knows about windows conventions as well as devdiv conventions
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.SymbolPath">
            <summary>
            The symbol path used to look up PDB symbol files.   Set when the reader is initialized.  
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.SourcePath">
            <summary>
            The paths used to look up source files.  defaults to _NT_SOURCE_PATH.  
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.SymbolCacheDirectory">
            <summary>
            Where symbols are downloaded if needed.   Derived from symbol path
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.SourceCacheDirectory">
            <summary>
            The place where source is downloaded from a source server.  
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.Flags">
            <summary>
            Is this symbol reader limited to just the local machine cache or not?
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.SecurityCheck">
            <summary>
            We call back on this when we find a PDB by probing in 'unsafe' locations (like next to the EXE or in the Built location)
            If this function returns true, we assume that it is OK to use the PDB.  
            </summary>
        </member>
        <member name="P:Symbols.SymbolReader.Log">
            <summary>
            A place to log additional messages 
            </summary>
        </member>
        <member name="T:Symbols.SymbolModule">
            <summary>
            A symbolReaderModule represents a single PDB.   You get one from SymbolReader.OpenSymbolFile
            It is effecively a managed interface to the Debug Interface Access (DIA) see 
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx for more.   I have only exposed what
            I need, and the interface is quite large (and not super pretty).  
            </summary>
        </member>
        <member name="M:Symbols.SymbolModule.FindNameForRva(System.UInt32)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found. 
            </summary>
        </member>
        <member name="M:Symbols.SymbolModule.SourceLocationForRva(System.UInt32)">
            <summary>
            Fetches the source location (line number and file), given the relative virtual address (RVA)
            of the location in the executable.  
            </summary>
        </member>
        <member name="M:Symbols.SymbolModule.SourceLocationForManagedCode(System.UInt32,System.Int32)">
            <summary>
            Managed code is shipped as IL, so RVA to NATIVE mapping can't be placed in the PDB. Instead
            what is placed in the PDB is a mapping from a method's meta-data token and IL offset to source
            line number.  Thus if you have a metadata token and IL offset, you can again get a source location
            </summary>
        </member>
        <member name="M:Symbols.SymbolModule.AllSourceFiles">
            <summary>
            Returns a list of all source files referenced in the PDB
            </summary>
        </member>
        <member name="P:Symbols.SymbolModule.PdbPath">
            <summary>
            The path name to the PDB itself
            </summary>
        </member>
        <member name="P:Symbols.SymbolModule.ExePath">
            <summary>
            This is the EXE associated with the Pdb.  It may be null or an invalid path.  It is used
            to help look up source code (it is implicitly part of the Source Path search) 
            </summary>
        </member>
        <member name="P:Symbols.SymbolModule.PdbIndexGuid">
            <summary>
            The PdbIndex a unique identifier that is used to relate the DLL and its PDB.   
            </summary>
        </member>
        <member name="P:Symbols.SymbolModule.SymbolReader">
            <summary>
            The symbol reader this SymbolModule was created from.  
            </summary>
        </member>
        <member name="F:Symbols.SymbolReaderFlags.None">
            <summary>
            No options this is the common case, where you want to look up everything you can. 
            </summary>
        </member>
        <member name="F:Symbols.SymbolReaderFlags.CacheOnly">
            <summary>
            Only fetch the PDB if it lives in the symbolCacheDirectory (is local an is generated).  
            This will generate NGEN pdbs unless the NoNGenPDBs flag is set. 
            </summary>
        </member>
        <member name="F:Symbols.SymbolReaderFlags.NoNGenPDB">
            <summary>
            No NGEN PDB generation.  
            </summary>
        </member>
        <member name="T:Symbols.SourceFile">
            <summary>
            A source file represents a source file from a PDB.  This is not just a string
            because the file has a build time path, a checksum, and it needs to be 'smart'
            to copy down the file if requested.  
            </summary>
        </member>
        <member name="M:Symbols.SourceFile.GetSourceFile">
            <summary>
            This may fetch things from the source server, and thus can be very slow, which is why it is not a property. 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Symbols.SourceLocation">
            <summary>
            A SourceLocation represents a point in the source code.  That is the file and the line number.  
            </summary>
        </member>
        <member name="T:Dia2Lib.DiaLoader">
            <summary>
            The DiaLoader class knows how to load the msdia100.dll (the Debug Access Interface) (see docs at
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx), without it being registered as a COM object.
            Basically it just called the DllGetClassObject interface directly.
            
            It has one public method 'GetDiaSourceObject' which knows how to create a IDiaDataSource object. 
            From there you can do anything you need.  
            </summary>
        </member>
        <member name="M:Dia2Lib.DiaLoader.GetDiaSourceObject">
            <summary>
            Load the msdia100 dll and get a IDiaDataSource from it.  This is your gateway to PDB reading.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.DynamicTraceEventParser">
            <summary>
            A DynamicTraceEventParser is a parser that understands how to read the embedded manifests that occur in the 
            dataStream (System.Diagnostics.Tracing.EventSources do this).   
            
            See also code:TDHDynamicTraceEventParser which knows how to read the manifest that are registered globally with
            the machine.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.DynamicTraceEventParser.AddDynamicProvider(Diagnostics.Tracing.Parsers.ProviderManifest)">
            <summary>
            Given a manifest describing the provider add its information to the parser.  
            </summary>
            <param name="providerManifest"></param>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.DynamicTraceEventParser.WriteAllManifests(System.String)">
            <summary>
            Utility method that stores all the manifests known to the DynamicTraceEventParser to the directory 'directoryPath'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.DynamicTraceEventParser.ReadAllManifests(System.String)">
            <summary>
            Utility method that read all the manifests the directory 'directoryPath' into the parser.  
            </summary>        
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DynamicTraceEventParser.DynamicProviders">
            <summary>
            Returns a list of providers (their manifest) that this TraceParser knows about.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.ProviderManifest">
            <summary>
            A ProviderManifest represents the XML manifest associated with teh provider.    
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializable">
            <summary>
            A type can opt into being serializable by implementing code:IFastSerializable and a default constructor
            (constructor that takes not arguments).
            
            Conceputally all clients of code:IFastSerializable also implement code:IFastSerializableVersion
            however the serializer will assume a default implementation of code:IFastSerializableVersion (that
            returns version 1 and assumes all versions are allowed to deserialize it.  
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.ToStream(FastSerialization.Serializer)">
            <summary>
            Given a Serializer, write youself to the output stream. Conceptually this routine is NOT
            responsible for serializing its type information but only its field values. However it is
            conceptually responsible for the full transitive closure of its fields.
            
            * For primitive fields, the choice is easy, simply call code:Serializer.Write
            * For object fields there is a choice
                * If is is only referneces by the enclosing object (eg and therefore field's lifetime is
                    identical to referencing object), then the code:Serialize.WritePrivateObject can be
                    used.  This skips placing the object in the interning table (that insures it is written
                    exactly once).  
                * Otherwise call code:Serialize.WriteObject
            * For value type fields (or collections of structs), you serialize the component fields.  
            * For collections, typically you serialize an integer inclusiveCountRet followed by each object. 
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.FromStream(FastSerialization.Deserializer)">
            <summary>
            
            Given a reader, and a 'this' instance, made by calling the default constructor, create a fully
            initialized instance of the object from the reader stream.  The deserializer provides the extra
            state needed to do this for cyclic object graphs.  
            
            Note that it is legal for the instance to cache the deserializer and thus be 'lazy' about when
            the actual deserialization happens (thus large persisted strucutre on the disk might stay on the
            disk).  
            
            Typically the FromStream implementation is an exact mirror of the ToStream implementation, where
            there is a Read() for every Write(). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Read a ProviderManifest from a stream
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.String)">
            <summary>
            Read a ProviderManifest from a file. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ProviderManifest.WriteToStream(System.IO.Stream)">
            <summary>
            Writes the manifest to 'outputStream' (as UTF8 XML text)
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ProviderManifest.WriteToFile(System.String)">
            <summary>
            Writes the manifest to a file 'filePath' (as a UTF8 XML)
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.ProviderManifest.Manifest">
            <summary>
            Retrieve manifest as one big string.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.ProviderManifest.ManifestReader">
            <summary>
            Retrieve the manifest as XML
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.DynamicTraceEventData">
            <summary>
            DynamicTraceEventData is an event that knows how to take runtime information to parse event fields (and payload)
            
            This meta-data is distilled down to a array of field names and an array of PayloadFetches which contain enough
            information to find the field data in the payload blob.   This meta-data is used in the 
            code:DynamicTraceEventData.PayloadNames and code:DynamicTraceEventData.PayloadValue methods.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.DynamicManifestTraceEventData">
            <summary>
            This class is only used to pretty-print the manifest event itself.   It is pretty special purpose
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.DynamicTraceEventParserState">
            <summary>
            DynamicTraceEventParserState represents the state of a  DynamicTraceEventParser that needs to be
            serialied to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.ETWTraceEventSource">
            <summary>
            A code:ETWTraceEventSource represents the stream of events that was collected from a
            code:TraceEventSession (eg the ETL moduleFile, or the live session event stream). Like all
            code:TraceEventSource, it logically represents a stream of code:TraceEvent s. Like all
            code:TraceEventDispather s it supports a callback model where Parsers attach themselves to this
            soures, and user callbacks defined on the parsers are called when the 'Process' methodIndex is called.
            
            * See also code:TraceEventDispatcher
            * See also code:TraceEvent
            * See also code:#ETWTraceEventSourceInternals
            * See also code:#ETWTraceEventSourceFields
            </summary>    
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventDispatcher">
            <summary>
            A code:TraceEventDispatcher is a code:TraceEventSource that supports a callback model for dispatching
            events. Like all code:TraceEventSource, it represents a list of code:TraceEvent however a
            code:TracEventDispatcher in addition has a hash table (from event GUI and EventID to code:TraceEvent)
            that is filled in when RegisterEventTemplate is called. Once registration is complete, calling
            code:TraceEventDispatcher.Process() will cause the callbacks to be triggered (in order)
            
            See also code:ETWTraceEventSource a dispatcher tailored for reading ETL files.
            See also code:ETLXTraceEventSource a dispatcher tailored for reading ETLX files. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventSource">
            <summary>
            code:TraceEventSource represents a list of events (eg a ETL file or ETLX file or a real time stream).
            There are two basic models for acessing such a list, either a callback model (where clients register
            their desire to know about particular events), and the iterator model (where you can use a 'foreach'
            on the list to get each event in turn. code:TraceEventSource represnts all those aspects of the list
            of event that is INDEPENDENT of which model you use. Thus code:TraceEventSource does not actually
            have the most interesting methods (Because the interesting methods deal with getting at the events)
            those actually are on sublasses
            
                * code:TraceEventDispatcher - is a subclass of code:TraceEventSource that supports the callback
                    model for accessing events. This interface can be used with 'real time' streams.
                * code:Diagnostics.Tracing.Parsers.TraceLog.TraceLog - is also a subclass of
                    code:TraceEventSource that supports the iteration model (through its
                    code:Diagnostics.Tracing.Parsers.TraceLog.TraceLog.Events property. This mechanism can only
                    be used on files, because it supports a much broader variety of access methods (eg moving
                    backwards, annotating events ...)
            
            Regardless of the model used to access the events, an important aspect of the system is that
            code:TraceEventSource does not know about the event-specific layout of an event (which allows new
            events to be added easily). Instead there needs to be a way for event specific
            parsers to register themselves (this is needed regarless of whether the callback or
            iterator model is used).  Providing the interface to do this is the primary purpose
            of code:TraceEventSource and is defined by the code:ITraceParserServices 
                 
            * see code:#Introduction for details
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.ITraceParserServices">
            <summary>
            code:TraceEventSource has two roles.  The first is the obvious one of providing some properties
            like 'SessionStartTime' for clients.  The other role is provide an anchor for code:TraceEventParser
            to 'hook' to so that events can be decoded.  code:ITraceParserServices is the API service for this
            second role.  It provides the methods that parsers use attach themselves to sources and register the
            fact that they undertand how to decode certain events.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ITraceParserServices.RegisterEventTemplate(Diagnostics.Tracing.TraceEvent)">
            <summary>
            RegisterEventTemplate is the mechanism a particular event payload description 'template' (a
            subclass of code:TraceEvent) is injected into the event processing stream. Once registered, an
            event is 'parsed' simply by setting the 'rawData' field in the event. It is up to the template
            then to take this raw data an present it in a useful way to the user (via properties). Note that
            parsing is thus 'lazy' in no processing of the raw data is not done at event dispatch time but
            only when the properties of an event are accessed.
            
            Another important aspect is that templates are reused by code:TraceEventSource agressively. The
            expectation is that no memory needs to be allocated during a normal dispatch (in fact only one
            field in the code:TraceEvent is set).
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ITraceParserServices.RegisterParser(Diagnostics.Tracing.TraceEventParser)">
            <summary>
            It is expected that when a subclass of code:TraceEventParser is created, it calls this
            methodIndex on the source.  This allows the source to do any Parser-specific initialization.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ITraceParserServices.RegisterUnhandledEvent(System.Func{Diagnostics.Tracing.TraceEvent,Diagnostics.Tracing.TraceEvent})">
            <summary>
            Indicates that this callback should be called on any unhandled event.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ITraceParserServices.TaskNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered an event with task with 'taskGuid'. Will return null if
            there is no registered event.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ITraceParserServices.ProviderNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered with the given GUID OR has registered any task that mathces
            the GUID. Will return null if there is no registered event.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSource.RelativeTimeMSec(System.Int64)">
            <summary>
            Returns a double representing the number of milliseconds 'time100ns' is from the offset of the log 
            </summary>
            <param name="time100ns">The time to convert to relative form</param>
            <returns>number of milliseconds from the begining of the log</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSource.RelativeTimeMSecTo100ns(System.Double)">
            <summary>
            Converts from a time in MSec from the begining of the trace to a 100ns timestamp.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSource.Dispose">
            <summary>
            Should be called when you are done with the source.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.Kernel">
            <summary>
            For convinience, we provide a property that will instantiate an object that knows how to parse
            all the Kernel events into callbacks.  See code:KernelTraceEventParser for more 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.Dynamic">
            <summary>
            For convinience, we provide a property that will instantiate an object that knows how to parse
            all providers that dump their manifests into the event stream.  See code:DynamicTraceEventParser for more 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.SessionStartTime">
            <summary>
            The time when session started logging. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.SessionStartTime100ns">
            <summary>
            The time is expressed as a windows moduleFile time (100ns ticks since 1601). This is very
            efficient and useful for finding deltas between events quickly.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.SessionEndTime">
            <summary>
            The time that the session stopped logging.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.SessionEndTime100ns">
            <summary>
            The end time expresses as a windows moduleFile time (100ns ticks since 1601).  This is very efficient
            and useful for finding deltas between events quickly.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.SessionDuration">
            <summary>
            The differnet between SessionEndTime and SessionStartTime;
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.Size">
            <summary>
            The size of the trace, if it is known.  Will return 0 if it is not known.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.PointerSize">
            <summary>
            Returns the size of a pointer on the machine where events were collected. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.EventsLost">
            <summary>
            The number of events that were dropped (event rate was too fast)
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.NumberOfProcessors">
            <summary>
            The number of processors on the machine doing the logging. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.CpuSpeedMHz">
            <summary>
            Cpu speed of the processor doing the logging. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.OSVersion">
            <summary>
            The version of the windows OS
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.UserData">
            <summary>
            code:TraceEventSource support attaching arbitary user data to the source.  One convetion that
            has been established is that parsers that need additional state to parse their events should
            store them in 'parsers\(ParserName)'.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSource.QPCFreq">
            <summary>
            This is the high frequency tick clock on the processor (what QueryPerformanceCounter uses).  
            You should not need 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.Process">
            <summary>
            Once a client has subscribed to the events of interest, calling Process actually causes
            the callbacks to happen.   
            </summary>
            <returns>false If StopProcesing was called</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.StopProcessing">
            <summary>
            Calling this function in a callback when 'Process' is running will indicate that processing
            should be stopped immediately. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.Dispatch(Diagnostics.Tracing.TraceEvent)">
            <summary>
            This is the routine that is called back when any event arrives.  Basically it looks up the GUID
            and the opcode associated with the event and finds right subclass of code:TraceEvent that
            knows how to decode the packet, and calls its virtual code:TraceEvent.Dispatch methodIndex.  Note
            that code:TraceEvent does NOT have a copy of hte data, but rather just a pointer to it. 
            This data is ONLY valid during the callback. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.Lookup(Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_RECORD*)">
            <summary>
            Lookup up the event based on its ProviderID (GUID) and EventId (Classic use the TaskId and the
            Opcode field for lookup, but use these same fields (see code:ETWTraceEventSource.RawDispatchClassic)
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.Insert(Diagnostics.Tracing.TraceEvent)">
            <summary>
            Inserts 'template' into the hash table, using 'providerGuid' and and 'eventID' as the key. 
            For Vista ETW events 'providerGuid' must match the provider GUID and the 'eventID' the ID filed.
            For PreVist ETW events 'providerGuid must match the task GUID the 'eventID' is the Opcode
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventDispatcher.GenTaskGuidFromProviderGuid(System.Guid,System.UInt16)">
            <summary>
            A helper for creating a set of related guids (knowing the providerGuid can can deduce the
            'taskNumber' member of this group.  All we do is add the taskNumber to GUID as a number.  
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.TraceEventDispatcher.UnhandledEvent">
            <summary>
            This event is called if no other hander has processed the event. Generally it is best not to use
            this if possible as it means that no filtering can be done by ETWTraceEventSource.
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.TraceEventDispatcher.EveryEvent">
            <summary>
            This event is called on every event in the trace.  Generally you should be picking off just he
            events you want by using subclasses of code:ETWTraceEventSource like code:Kernel and code:CLR to
            subscribe to specific events, but sometimes you want to uniformly process every event.  
            
            This is called AFTER any event-specific handlers.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String)">
            <summary>
            Open a ETW event trace moduleFile (ETL moduleFile) for processing.  
            </summary>
            <param name="fileName">The ETL data moduleFile to open</param>
        </member>
        <member name="M:Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String,Diagnostics.Tracing.TraceEventSourceType)">
            <summary>
            Open a ETW event source for processing.  This can either be a moduleFile or a real time ETW session
            </summary>
            <param name="fileOrSessionName">
            If type == ModuleFile this is the name of the moduleFile to open.
            If type == Session this is the name of real time sessing to open.</param>
            <param name="type"></param>
        </member>
        <member name="M:Diagnostics.Tracing.ETWTraceEventSource.Process">
            <summary>
            Processes all the events in the data soruce, issuing callbacks that were subscribed to.  See
            code:#Introduction for more
            </summary>
            <returns>false If StopProcesing was called</returns>
        </member>
        <member name="M:Diagnostics.Tracing.ETWTraceEventSource.Close">
            <summary>
            Closes the ETL moduleFile or detaches from the session.  
            </summary>  
        </member>
        <member name="P:Diagnostics.Tracing.ETWTraceEventSource.LogFileName">
            <summary>
            The log moduleFile that is being processed (if present)
            TODO: what does this do for Real time sessions?
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.ETWTraceEventSource.SessionName">
            <summary>
            The name of the session that generated the data. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.ETWTraceEventSource.Size">
            <summary>
            The size of the log, will return 0 if it does not know. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.ETWTraceEventSource.CanReset">
            <summary>
            Returns true if the code:Process can be called mulitple times (if the Data source is from a
            moduleFile, not a real time stream.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventSourceType">
            <summary>
            The kinds of data sources that can be opened (see code:ETWTraceEventSource)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventSourceType.MergeAll">
            <summary>
            Look for any files like *.etl or *.*.etl (the later holds things like *.kernel.etl or *.clrRundown.etl ...)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventSourceType.FileOnly">
            <summary>
            Look for a ETL moduleFile *.etl as the event data source 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventSourceType.Session">
            <summary>
            Use a real time session as the event data source.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ManifestEnvelope">
            <summary>
            Used to send the rawManifest into the event stream as a series of events.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.BulkNodeElement32">
            <summary>
            This is the layout on a 32 bit system.   
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetPdbSignature(System.String@,System.Guid@,System.Int32@,System.Boolean)">
            <summary>
            Looks up the debug signature information in the EXE.   Returns true and sets the parameters if it is found. 
            
            If 'first' is true then the first entry is returned, otherwise (by default) the last entry is used 
            (this is what debuggers do today).   Thus NGEN images put the IL PDB last (which means debuggers 
            pick up that one), but we can set it to 'first' if we want the NGEN PDB.
            </summary>
        </member>
        <member name="P:PEFile.PEFile.Header">
            <summary>
            The Header for the PE file.  This contains the infor in a link /dump /headers 
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.#ctor(System.IntPtr)">
            <summary>
            Returns a PEHeader for pointer in memory.  It does NO validity checking. 
            </summary>
            <param name="startOfPEFile"></param>
        </member>
        <member name="M:PEFile.PEHeader.Dispose">
            <summary>
            PEHeader pins a buffer, if you wish to eagerly dispose of this, it can be done here.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Size">
            <summary>
            The total size, including section array of the the PE header.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSource">
            <summary>
            It is the abstract contract for a sample.  All we need is the Metric and 
            </summary>    
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceStacks">
            <summary>
            Samples have stacks (lists of frames, each frame contains a name) associated with them.  This interface allows you to get 
            at this information.  We don't use normal objects to represent these but rather give each stack (and frame) a unique
            (dense) index.   This has a number of advantages over using objects to represent the stack.
            
                * Indexes are very serialization friendly, and this data will be presisted.  Thus indexes are the natural form for data on disk. 
                * It allows the data to be read from the serialized format (disk) lazily in a very straightfoward fashion, keeping only the
                    hottest elements in memory.  
                * Users of this API can associate additional data with the call stacks or frames trivially and efficiently simply by
                    having an array indexed by the stack or frame index.   
                    
            So effecively a StackSourceStacks is simply a set of 'Get' methods that allow you to look up information given a Stack or
            frame index.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceStacks.GetCallerIndex(Diagnostics.Tracing.StackSources.StackSourceCallStackIndex)">
            <summary>
            Given a call stack, return the call stack of the caller.   This function can return StackSourceCallStackIndex.Discard
            which means that this sample should be discarded.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceStacks.GetFrameIndex(Diagnostics.Tracing.StackSources.StackSourceCallStackIndex)">
            <summary>
            For efficiency, m_frames are assumed have a integer ID instead of a string name that
            is unique to the frame.  Note that it is expected that GetFrameIndex(x) == GetFrameId(y) 
            then GetFrameName(x) == GetFrameName(y).   The converse does NOT have to be true (you 
            can reused the same name for distict m_frames, however this can be confusing to your
            users, so be careful.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceStacks.GetNumberOfFoldedFrames(Diagnostics.Tracing.StackSources.StackSourceCallStackIndex)">
            <summary>
            FilterStackSources can combine more than one frame into a given frame.  It is useful to know
            how many times this happened.   Returning 0 means no combining happened.  This metric does
            not include grouping, but only folding.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceStacks.GetFrameName(Diagnostics.Tracing.StackSources.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get the frame name from the FrameIndex.   If 'verboseName' is true then full module path is included.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSourceStacks.CallStackIndexLimit">
            <summary>
            all StackSourceCallStackIndex are guarenteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSourceStacks.CallFrameIndexLimit">
            <summary>
            all StackSourceFrameIndex are guarenteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSource.GetSampleByIndex(Diagnostics.Tracing.StackSources.StackSourceSampleIndex)">
            <summary>
            If this source supports fetching the samples by index, this is how you get it.  Like ProduceSamples the sample that
            is returned is not allowed to be modified.   Also the returned sample will become invalid the next time GetSampleIndex
            is called (we reuse the StackSourceSample on each call)
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSource.GetRefs(Diagnostics.Tracing.StackSources.StackSourceSampleIndex,Diagnostics.Tracing.StackSources.RefDirection,System.Action{Diagnostics.Tracing.StackSources.StackSourceSampleIndex})">
            <summary>
            Only used if IsGraphSource==true.   If 'dir' is 'From' Calls 'callback' for node that is refered to FROM nodeIndex.
            If 'dir' is 'To' then it calls 'callback' for every node that refers TO nodeIndex.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSource.BaseStackSource">
            <summary>
            If this stack source is a source that simply groups another source, get the base source.  It will return
            itself if there is no base source.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSource.SamplingRate">
            <summary>
            StackSources can optionally support a sampling rate.   If the source supports it it will return
            non-null for the current sampling rate (1 if it is doing nothing).    Sampling is a way of speeding
            things up.  If you sample at a rate of 10, it means that only one out of every 10 samples is actually
            produced by 'ProduceSamples'.   Note that it is expected that when the sampling rate is set the 
            source will correspondingly adjust the CountMultiplier, so that the total will look like no sampling
            is occuring 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSource.IsGraphSource">
            <summary>
            If each 'callstack' is really a node in a graph (like MemoryGraphStackSource)
            Then return true.  If this returns true 'GetRefs' works. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceSample">
            <summary>
            StackSourceSample represents a single sample that has a stack.  StackSource.GetNextSample returns these.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSourceSample.Count">
            <summary>
            Normally the count of a sample is 1, however when you take a statistical sample, and you also have 
            other constraints (like you do when you are going a sample of heap memory),  you may need to have the
            count adjusted to something else.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceSampleIndex">
            <summary>
            Identifies a particular sample from the sample source, it allows 3rd parties to attach additional
            information to the sample by creating an array indexed by sampleIndex.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceCallStackIndex">
            <summary>
            An opaque handle that are 1-1 with a complete call stack
            
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceFrameIndex">
            <summary>
            Identifies a particular frame within a stack   It represents a particular instruction pointer (IP) location 
            in the code or a group of such locations.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.CopyStackSource">
            <summary>
            This stack source takes another and copies out all its events.   This allows you to 'replay' the source 
            efficiently when the original source only does this inefficiently.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.InternStackSource">
            <summary>
            Like CopyStackSource InternStackSource copies the samples. however unlike CopyStackSource
            InternStackSource copies all the information in the stacks too (mapping stack indexes to names)
            Thus it never refers to the original source again).   It also interns the stacks making for 
            an efficient representation of the data.   This is useful when the original source is expensive 
            to iterate over.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.InternStackSource.Diff(Diagnostics.Tracing.StackSources.StackSource,Diagnostics.Tracing.StackSources.StackSource)">
            <summary>
            Compute the difference between two sources of stacks.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.InternStackSource.Diff(Diagnostics.Tracing.StackSources.StackSource,Diagnostics.Tracing.StackSources.StackSourceStacks,Diagnostics.Tracing.StackSources.StackSource,Diagnostics.Tracing.StackSources.StackSourceStacks)">
            <summary>
            Compute only the delta of source from the baseline.  This variation allows you to specify
            the unfiltered names (the sourceStacks and baselineStacks) but otherwise keep the filtering.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.InternStackSource.InternFullStackFromSource(Diagnostics.Tracing.StackSources.StackSourceCallStackIndex,Diagnostics.Tracing.StackSources.StackSourceStacks)">
            <summary>
            InternFullStackFromSource will take a call stack 'baseCallStackIndex' from the source 'source' and completely copy it into
            the intern stack source (interning along the way of course).   Logically baseCallStackIndex has NOTHING to do with any of the
            call stack indexes in the intern stack source.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackSourceInterner">
            <summary>
            StackSourceInterner is a helper class that knows how to intern module, frame and call stacks. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceInterner.DoneInterning">
            <summary>
            As an optimization, if you are done adding new nodes, then you can call this routine can abadon
            some tables only needed during the interning phase.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceInterner.GetFrameName(Diagnostics.Tracing.StackSources.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get a name from a frame index.  If the frame index is a 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.StackSourceInterner.FrameIntern(Diagnostics.Tracing.StackSources.StackSourceFrameIndex,System.String)">
            <summary>
            You can also create frames out of other frames using this method.  Given an existing frame, and
            a suffix 'frameSuffix' 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.StackSourceInterner.FrameNameLookup">
            <summary>
            If you intern frames as derived frames, when GetFrameName is called the interner needs to know
            how to look up the derived frame from its index.  This is the function that is called.  
            
            It is called with the frame index and a boolean which indicats whether the full path of the module 
            should be specified, and returns the frame string. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.HistogramCharacterIndex">
            <summary>
            An enum representing a displayed histogram bucket (one character in a histogram string).
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.HistogramController">
             <summary>
             A Histogram is conceputually an array of floating point values.   A Histogram Controller
             contains all the information besides the values themselves need to understand the array
             of floating point value.   There are alot of Histograms, however they all tend to share
             the same histogram controller.   Thus Histograms know their Histogram controller, but not
             the reverse.  
             
             Thus HistogramContoller is a abstract class (we have one for time, and one for scenarios).  
            
             HistogramControllers are responsible for:
             
             - Adding a sample to the histogram for a node (see <see cref="M:Diagnostics.Tracing.StackSources.HistogramController.AddSample(Diagnostics.Tracing.StackSources.Histogram,Diagnostics.Tracing.StackSources.StackSourceSample)"/>)
             - Converting a histogram to its string representation see (<see cref="M:Diagnostics.Tracing.StackSources.HistogramController.GetDisplayString(Diagnostics.Tracing.StackSources.Histogram)"/>)
             - Managing the size and scale of histograms and their corresponding display strings
             </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.#ctor(Diagnostics.Tracing.StackSources.CallTree)">
            <summary>
            Initialize a new HistogramController.
            </summary>
            <param name="tree">The CallTree that this HistogramController controls.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.InvalidateScale">
            <summary>
            Force recalculation of the scale parameter.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.AddSample(Diagnostics.Tracing.StackSources.Histogram,Diagnostics.Tracing.StackSources.StackSourceSample)">
            <summary>
            Add a sample to the histogram for a node.
            </summary>
            <param name="histogram">The histogram to add this sample to. Must be controlled by this HistogramController.</param>
            <param name="sample">The sample to add.</param>
            <remarks>
            Overriding classes are responsible for extracting the metric, scaling the metric,
            determining the appropriate bucket or buckets, and adding the metric to the histogram using <see cref="M:Diagnostics.Tracing.StackSources.Histogram.AddMetric(System.Single,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.GetInfoForCharacterRange(Diagnostics.Tracing.StackSources.HistogramCharacterIndex,Diagnostics.Tracing.StackSources.HistogramCharacterIndex,Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Gets human-readable information about a range of histogram characters.
            </summary>
            <param name="start">The start character index (inclusive).</param>
            <param name="end">The end character index (exclusive).</param>
            <returns>A string containing information about the contents of that character range.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.GetDisplayString(Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Convert a histogram into its display string.
            </summary>
            <param name="histogram">The histogram to convert to a string.</param>
            <returns>A string suitable for GUI display.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.HistogramString(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.HistogramString(System.Single[],System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for this histogram.
            </summary>
            <returns>The scale factor for this histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.HistogramController.CalculateAverageScale(Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Calculates an average scale factor for a histogram.
            </summary>
            <param name="hist">The root histogram to calculate against.</param>
            <returns>A scale factor that will normalize the maximum value to 200%.</returns>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.HistogramController.m_scale">
            <summary>
            The scale parameter. 0.0 if uncalculated.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.HistogramController.Scale">
            <summary>
            The scale factor for histograms controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.HistogramController.BucketCount">
            <summary>
            The number of buckets in each histogram controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.HistogramController.CharacterCount">
            <summary>
            The number of characters in the display string for histograms controlled by this HistogramController.
            Buckets are a logial concept, where CharacterCount is a visual concept (how many you can see on the 
            screen right now).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.HistogramController.Tree">
            <summary>
            The CallTree managed by this HistogramController.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.ScenarioHistogramController">
            <summary>
            A <see cref="T:Diagnostics.Tracing.StackSources.HistogramController"/> that groups histograms by scenarios.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.#ctor(Diagnostics.Tracing.StackSources.CallTree,System.Int32[],System.Int32,System.String[])">
            <summary>
            Initialize a new ScenarioHistogramController.
            </summary>
            <param name="tree">The CallTree to manage.</param>
            <param name="scenarios">An ordered array of scenario IDs to display.</param>
            <param name="totalScenarios">The total number of possible scenarios that can be supplied by the underlying StackSource.
            This number might be larger than the highest number in <paramref name="scenarios"/>.</param>
            <param name="scenarioNames">The names of the scenarios (for UI use).</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.GetScenariosForCharacterIndex(Diagnostics.Tracing.StackSources.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket.
            </summary>
            <param name="bucket">The bucket to look up.</param>
            <returns>The scenarios contained in that bucket.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.GetScenariosForCharacterRange(Diagnostics.Tracing.StackSources.HistogramCharacterIndex,Diagnostics.Tracing.StackSources.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket range.
            </summary>
            <param name="start">The start of the bucket range (inclusive).</param>
            <param name="end">The end of the bucket range (exclusive).</param>
            <returns>The scenarios contained in that range of buckets.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for all histograms controlled by this ScenarioHistogramController.
            </summary>
            <returns>
            In the current implementation, returns a scale that normalizes 100% to half of the maximum value at the root.
            </returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.AddSample(Diagnostics.Tracing.StackSources.Histogram,Diagnostics.Tracing.StackSources.StackSourceSample)">
            <summary>
            Add a sample to a histogram controlled by this HistogramController.
            </summary>
            <param name="histogram">The histogram to add the sample to.</param>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.GetNameForScenario(System.Int32)">
            <summary>
            Get the human-readable name for a scenario.
            </summary>
            <param name="scenario">The ID of the scenario to look up.</param>
            <returns>The human-readable name for that scenario.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.GetInfoForCharacterRange(Diagnostics.Tracing.StackSources.HistogramCharacterIndex,Diagnostics.Tracing.StackSources.HistogramCharacterIndex,Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Get the human-readable names for all scenarios contained in a range of histogram characters.
            </summary>
            <param name="start">The (inclusive) start index of the range.</param>
            <param name="end">The (exclusive) end index of the range.</param>
            <returns>A comma-separated list of scenario names contained in that range.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.ScenarioHistogramController.GetDisplayString(Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Convert a histogram into a string suitable for UI display.
            </summary>
            <param name="histogram">The histogram to convert.</param>
            <returns>A string representing the histogram that is suitable for UI display.</returns>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.ScenarioHistogramController.m_characterFromScenario">
            <summary>
            An array mapping each scenario to a bucket.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.ScenarioHistogramController.m_scenariosFromCharacter">
            <summary>
            An array mapping each bucket to a list of scenarios.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.ScenarioHistogramController.m_scenarioNames">
            <summary>
            An array mapping each scenario to its name.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.TimeHistogramController">
            <summary>
            A HistogramController holds all the information to understand the buckets of a histogram
            (basically everything except the array of metrics itself.   For time this is the
            start and end time  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.TimeHistogramController.#ctor(Diagnostics.Tracing.StackSources.CallTree,System.Double,System.Double)">
            <summary>
            Create a new TimeHistogramController.
            </summary>
            <param name="tree">The CallTree to control with this controller.</param>
            <param name="start">The start time of the histogram.</param>
            <param name="end">The end time of the histogram.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.TimeHistogramController.GetStartTimeForBucket(Diagnostics.Tracing.StackSources.HistogramCharacterIndex)">
            <summary>
            Gets the start time for the histogram bucket represented by a character.
            </summary>
            <param name="bucket">The index of the character to look up.</param>
            <returns>The start time of the bucket represented by the character.</returns>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.TimeHistogramController.Start">
            <summary>
            The start time of the histogram.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.TimeHistogramController.End">
            <summary>
            The end time of the histogram.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.TimeHistogramController.BucketDuration">
            <summary>
            The duration of time represented by each bucket.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.Histogram">
            <summary>
            A Histogram is logically an array of floating point values.  Often they
            represent frequency, but it can be some other metric.  The X axis can 
            represent different things (time, scenario).  It is the HisogramContoller
            which understands what the X axis is.   Histograms know their HistogramController
            but not the reverse.  
            
            Often Histograms are sparse (most array elements are zero), so the represnetation
            is designed to optimzed for this case (an array of non-zero index, value pairs). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.#ctor(Diagnostics.Tracing.StackSources.HistogramController)">
            <summary>
            Create a new histogram.
            </summary>
            <param name="controller">The <see cref="T:Diagnostics.Tracing.StackSources.HistogramController"/> to control this Histogram/</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.AddSample(Diagnostics.Tracing.StackSources.StackSourceSample)">
            <summary>
            Add a sample to this histogram.
            </summary>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.AddMetric(System.Single,System.Int32)">
            <summary>
            Add an amount to a bucket in this histogram.
            </summary>
            <param name="metric">The amount to add to the bucket.</param>
            <param name="bucket">The bucket to add to.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.op_Addition(Diagnostics.Tracing.StackSources.Histogram,Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Adds two Histograms together.
            </summary>
            <param name="left">The first histogram to add.</param>
            <param name="right">The second histogram to add.</param>
            <returns>The summed histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.op_Subtraction(Diagnostics.Tracing.StackSources.Histogram,Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Subtract one Histogram from another.
            </summary>
            <param name="left">The histogram to subtract from.</param>
            <param name="right">The histogram to subtract.</param>
            <returns>The subtracted histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.op_Multiply(System.Double,Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Scales a histogram by a scalar.
            </summary>
            <param name="scalar">The scalar to scale by.</param>
            <param name="vec">The histogram to scale.</param>
            <returns>The scaled histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.op_Multiply(Diagnostics.Tracing.StackSources.Histogram,System.Double)">
            <summary>
            Scales a histogram by a scalar.
            </summary>
            <param name="scalar">The scalar to scale by.</param>
            <param name="vec">The histogram to scale.</param>
            <returns>The scaled histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.Clone">
            <summary>
            Make a copy of this histogram.
            </summary>
            <returns>An independent copy of this histogram.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.#ctor(Diagnostics.Tracing.StackSources.Histogram)">
            <summary>
            Create a histogram that is a copy of another histogram.
            </summary>
            <param name="other">The histogram to copy.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.Histogram.GetEnumerable">
            <summary>
            Get an IEnumerable that can be used to enumerate the metrics stored in the buckets of this Histogram.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.Histogram.m_controller">
            <summary>
            The controller for this histogram.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.Histogram.m_buckets">
            <summary>
            A sparse list of metrics in this histogram. Zero metrics are not stored, and are generated on demand.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.Histogram.Count">
            <summary>
            The number of buckets in this histogram.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.Histogram.Controller">
            <summary>
            The <see cref="T:Diagnostics.Tracing.StackSources.HistogramController"/> that controls this histogram.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.Histogram.Item(System.Int32)">
            <summary>
            Get the metric contained in a bucket.
            </summary>
            <param name="index">The bucket to retrieve.</param>
            <returns>The metric contained in that bucket.</returns>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.CallTree">
            <summary>
            SampleInfos of a set of stackSource by eventToStack.  This represents the entire call tree.   You create an empty one in using
            the default constructor and use 'AddSample' to add stackSource to it.   You traverse it by 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTree.#ctor(Diagnostics.Tracing.StackSources.ScalingPolicyKind)">
            <summary>
            Creates an empty call tree.  Only useful so you can have a valid 'placeholder' value when you 
            have no samples.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTree.FoldNodesUnder(System.Single,System.Boolean)">
            <summary>
            If there are any nodes that have strictly less than to 'minInclusiveMetric'
            then remove the node, placing its samples into its parent (thus the parent's
            exclusive metric goes up).  
            
            If useWholeTraceMetric is true, nodes are only folded if their inclusive metric
            OVER THE WHOLE TRACE is less than 'minInclusiveMetric'.  If false, then a node
            is folded if THAT NODE has less than the 'minInclusiveMetric'  
            
            Thus if 'useWholeTraceMetric' == false then after calling this routine no
            node will have less than minInclusiveMetric.  
            
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTree.Sort(System.Comparison{Diagnostics.Tracing.StackSources.CallTreeNode})">
            <summary>
            Cause each treeNode in the calltree to be sorted (accending) based on comparer
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTree.SortInclusiveMetricDecending">
            <summary>
            Sorting by InclusiveMetric Decending is so common, provide a shortcut.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTree.AccumulateSumByID(Diagnostics.Tracing.StackSources.CallTreeNode,System.Collections.Generic.Dictionary{System.Int32,Diagnostics.Tracing.StackSources.CallTreeNodeBase})">
            <summary>
            Traverse the subtree of 'treeNode' into the m_sumByID dictionary.   We don't want to
            double-count inclusive times, so we have to keep track of all callers currently on the
            stack and we only add inclusive times for nodes that are not already on the stack.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTree.ScalingPolicy">
            <summary>
            When converting the InclusiveMetricByTime to a InclusiveMetricByTimeString you have to decide 
            how to scale the samples to the digits displayed in the string.  This enum indicates this policy
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTree.PercentageBasis">
            <summary>
            When calculating percentages, what do we use as 100%.  By default we use the
            Inclusive time for the root, but that can be changed here.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTree.ByID">
            <summary>
            Return a list of nodes that have statisicts rolled up by treeNode by ID.  It is not
            sorted by anything in particular.   Note that ID is not quite the same thing as the 
            name.  You can have two nodes that have different IDs but the same Name.  These 
            will show up as two distinct entries in the resulting list.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.ScalingPolicyKind.ScaleToData">
            <summary>
            This is the default.  In this policy, 100% is chosen so that the histogram is scaled as best it can.   
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.ScalingPolicyKind.TimeMetric">
            <summary>
            It assumes that the metric represents time 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.CallTreeNodeBase">
            <summary>
            The part of a CalltreeNode that is common to Caller-calleeSum and the Calltree view.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNodeBase.GetSamples(System.Boolean,System.Func{Diagnostics.Tracing.StackSources.StackSourceSampleIndex,System.Boolean})">
            <summary>
            Return all the original stack samples in this node.  If exclusive==true then just he
            sample exclusively in this node are returned, otherwise it is the inclusive samples.   
            
            If the original stack source that was used to create this CodeTreeNode was a FilterStackSource
            then that filtering is removed in the returned Samples.  
            
            returns the total number of samples (the number of times 'callback' is called)
            
            If the callback returns false, the iteration over samples stops. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNodeBase.GetTrees(System.Action{Diagnostics.Tracing.StackSources.CallTreeNode})">
            <summary>
            While 'GetSamples' can return all the samples in the tree, this is a relatively
            inefficient way of representing the samples.   Instead you can return a list of
            trees whose samples represent all the samples.   This is what GetTrees does.
            It calls 'callback' on a set of trees that taken as a whole have all the samples
            in 'node'.  
            
            Note you ave to be careful when using this for inclusive summation of byname nodes because 
            you will get trees that 'overlap' (bname nodes might refer into the 'middle' of another
            call tree).   This can be avoided pretty easily by simply stopping inclusive traversal 
            whenever a tree node with that ID occurs (see GetSamples for an example). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNodeBase.CombineByIdSamples(Diagnostics.Tracing.StackSources.CallTreeNodeBase,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Combines the 'this' node with 'otherNode'.   If 'newOnStack' is true, then the inclusive
            metrics are also updated.  
            
            Note that I DON'T accumlate other.m_samples into this.m_samples.   This is because we want to share
            samples as much a possible.  Thus nodes remeber their samples by pointing at other call trees
            and you fetch the samples by an inclusive walk of the tree.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNodeBase.GetSamplesForTreeNode(Diagnostics.Tracing.StackSources.CallTreeNode,System.Boolean,System.Func{Diagnostics.Tracing.StackSources.StackSourceSampleIndex,System.Boolean},Diagnostics.Tracing.StackSources.StackSourceFrameIndex)">
            <summary>
            To avoid double-counting for byname nodes, with we can be told to exclude any children with a particular ID 
            (the ID of the ByName node itself) if are doing the inclusive case.   The goal is to count every reachable
            tree exactly once.  We do this by conceptually 'marking' each node with ID at the top level (when they are 
            enumerated as children of the Byname node), and thus any node with that excludeChildrenWithID is conceptually
            marked if you encounter it as a child in the tree itself (so you should exclude it).  The result is that 
            every node is visited exactly once (without the expense of having a 'visited' bit).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTreeNodeBase.DisplayName">
            <summary>
            Currently the same as Name, but could contain additional info.  
            Suitable for display but not for programatic comparision.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTreeNodeBase.ID">
             <summary>
             The ID represents a most fine grained uniqueness associated with this node.   Typically it represents
             a particular method (however it is possible that two methods can have the same name (because the scope
             was not captured).   Thus there can be multiple nodes with the same Name but different IDs.   
             
             This can be StackSourceFrameIndex.Invalid for Caller-callee nodes (which have names, but no useful ID) 
            
             If ID != Invalid, and the IDs are the same then the names are guarenteed to be the same.  
             </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTreeNodeBase.CallTree">
            <summary>
            The call tree that contains this node.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.CallTreeNode">
            <summary>
            Represents a single treeNode in a code:CallTree 
            
            Each node keeps all the sample with the same path to the root.  
            Each node also remembers its parent (caller) and children (callees).
            The nodes also keeps the IDs of all its samples (so no information
            is lost, just sorted by stack).   You get at this through the
            code:CallTreeNodeBase.GetSamples method.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNode.GetBrokenStackCount">
            <summary>
            Adds up the counts of all nodes called 'BROKEN' nodes in a particular tree node
            
            This is a utility function.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNode.IndentString(System.Boolean)">
            <summary>
            Creates a string that has spaces | and + signs that represent the indentation level 
            for the tree node.  (Called from XAML)
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNode.GetCallees">
            <summary>
            Some calltrees already fill in their children, others do so lazily, in which case they 
            override this method.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallTreeNode.FoldNodesUnder(System.Single,System.Collections.Generic.Dictionary{System.Int32,Diagnostics.Tracing.StackSources.CallTreeNodeBase})">
            <summary>
            Fold away any nodes having less than 'minInclusiveMetric'.  If 'sumByID' is non-null then the 
            only nodes that have a less then the minInclusiveMetric for the whole trace are folded. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.CallTreeNode.AllCallees">
            <summary>
            DisplayCallees is a set of Callee that you actually display
            It always starts with the 'normal' Callee, however in addition if we are
            displaying a MemoryGraph, it will also show 'pruned' arcs (by calling GetRefs)
            so that you can see the whole graph if you like.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.CallerCalleeNode">
            <summary>
            A code:CallerCalleeNode gives statistics that focus on a NAME.  (unlike calltrees that use ID)
            It takes all stackSource that have callStacks that include that treeNode and compute the metrics for
            all the callers and all the callees for that treeNode.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallerCalleeNode.#ctor(System.String,Diagnostics.Tracing.StackSources.CallTree)">
            <summary>
            Given a complete call tree, and a Name within that call tree to focus on, create a
            CallerCalleeNode that represents the single Caller-Callee view for that treeNode. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallerCalleeNode.AccumlateSamplesForNode(Diagnostics.Tracing.StackSources.CallTreeNode,System.Int32,Diagnostics.Tracing.StackSources.CallTreeNodeBase@,System.Double@,System.Boolean@)">
            <summary>
            A caller callee view is a sumation which centers around one 'focus' node which is represented by the CallerCalleeNode.
            This node has a caller and callee list, and these nodes (as well as the CallerCalleNode itself) represent the aggregation
            over the entire tree.
            
            AccumlateSamplesForNode is the routine that takes a part of a aggregated call tree (repsesented by 'treeNode' and adds
            in the statistics for that call tree into the CallerCalleeNode aggregations (and its caller and callee lists).  
            
            'recursionsCount' is the number of times the focus node name has occured in the path from 'treeNode' to the root.   In 
            addition to setting the CallerCalleeNode aggregation, it also returns a 'weightedSummary' inclusive aggregation 
            FOR JUST treeNode (the CallerCalleNode is an aggregation over the entire call tree accumulated so far).  
            
            The key problem for this routine to avoid is double counting of inclusive samples in the face of recursive functions. 
            Thus all samples are weighted by the recurision count before being included in 'weightedSummaryRet (as well as in
            the CallerCalleeNode and its Callers and Callees).    
            
            An important optimization is the ability to NOT create (but rather reuse) CallTreeNodes when returning weightedSummaryRet.
            To accompish this the weightedSummaryScaleRet is needed.  To get the correct numerical value for weightedSummaryRet, you 
            actually have to scale values by weightedSummaryScaleRet before use.   This allows us to represent weights of 0 (subtree has 
            no calls to the focus node), or cases where the subtree is completely uniform in its weigthing (the subtree does not contain
            any additional focus nodes), by simply returning the tree node itself and scaling it by the recursion count).  
            
            isUniformRet is set to false if anyplace in 'treeNode' does not have the scaling factor weightedSummaryScaleRet.  This
            means the the caller cannot simply scale 'treeNode' by a weight to get weightedSummaryRet.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.CallerCalleeNode.Find(System.Collections.Generic.List{Diagnostics.Tracing.StackSources.CallTreeNodeBase}@,System.String)">
            <summary>
            Find the Caller-Callee treeNode in 'elems' with name 'frameName'.  Always succeeds because it
            creates one if necessary. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.AggregateCallTreeNode">
            <summary>
            AggregateCallTreeNode supports a multi-level caller-callee view.   
            
            It does this by allow you to take any 'focus' node (typically a byname node)
            and compute a tree of its callers and a tree of its callees.   You do this
            by passing the node of interested to either the 'CallerTree' or 'CalleeTrees'.
            
            The AggregateCallTreeNode remembers if if is a caller or callee node and its
            'Callees' method returns the children (which may in fact be Callers). 
            
            What is nice about 'AggregateCallTreeNode is that it is lazy, and you only 
            form the part of the tree you actually explore.     A classic 'caller-callee' 
            view is simply the caller and callee trees only explored to depth 1.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.CallerTree(Diagnostics.Tracing.StackSources.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callers of that node.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.CalleeTree(Diagnostics.Tracing.StackSources.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callees of that node.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.GetTrees(System.Action{Diagnostics.Tracing.StackSources.CallTreeNode})">
            <summary>
            Calls 'callback' for each distinct call tree in this node.  Note that the same
            trees can overlap (in the case of recursive functions), so you need a mechanism
            for visiting a tree only once.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.MergeCaller(Diagnostics.Tracing.StackSources.CallTreeNode,System.Collections.Generic.List{Diagnostics.Tracing.StackSources.CallTreeNode},System.Int32)">
            <summary>
            See m_callerOffset and MergeCallee for more.
            
            The 'this' node is a AggregateCallTree representing the 'callers' nodes.  Like 
            MergeCallee the agregate node represents a list of CallTreeNodes.   Howoever unlike
            MergeCallee, the list of CallTreeNodes each represent a sample (a complete call stack)
            and 'callerOffset' indicates how far 'up' that stack is the node of interest.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.MergeCallee(Diagnostics.Tracing.StackSources.CallTreeNode,System.Collections.Generic.List{Diagnostics.Tracing.StackSources.CallTreeNode})">
            <summary>
            An aggregateCallTreeNode is exactly that, the sum of several callTrees
            (each of which represent a number of individual samples).    Thus we had to 
            take each sample (which is 'treenode' and merge it into the aggregate.
            We do this one at a time.   Thus we call MergeCallee for each calltree 
            in our list and we find the 'callees' of each of those nodes, and create 
            aggregates for the children (which is in calleeList).   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.SubtractOutTrees(Diagnostics.Tracing.StackSources.CallTreeNode,Diagnostics.Tracing.StackSources.StackSourceFrameIndex,Diagnostics.Tracing.StackSources.AggregateCallTreeNode)">
            <summary>
            Traverse 'treeCallee' and subtract out the inclusive time for any tree that matches 'idToExclude' from the node 'statsRet'.
            This is needed in AggregateCallTrees because the same trees from the focus node are in the list to aggregate, but are also
            in the subtree's in various places (and thus are counted twice).   We solve this by walking this subtree (in this routine)
            and subtracting out any nodes that match 'idToExclude'.   
            
            As an optimization this routine also sets the m_recurision bit 'statsRet' if anywhere in 'treeCallee' we do find an id to 
            exclude.  That way in a common case (where there is no instances of 'idToExclude') we don't have to actualy walk the
            tree the second time (we simply know that there is no adjustment necessary.   
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.m_trees">
            <summary>
            An AggregateCallTree remembers all its samples by maintaining a list of calltrees 
            that actually contain the samples that the Aggregate respresents.  m_trees hold this.   
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateCallTreeNode.m_callerOffset">
            <summary>
            AggregateCallTreeNode can represent either a 'callers' tree or a 'callees' tree.   For 
            the 'callers' tree case the node represented by the aggregate does NOT have same ID as
            the tree in the m_trees list.   Instead the aggreegate is some node 'up the chain' toward 
            the caller.  m_callerOffset keeps track of this (it is the same number for all elements 
            in m_trees).   
            
            For callee nodes, this number is not needed.   Thus we use a illegal value (-1) to 
            represent that fact that the node is a callee node rather than a caller node.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.SymbolTraceEventParser">
            <summary>
            Kernel traces have information about images that are loaded, however they don't have enough information
            in the events themselves to unambigously look up PDBs without looking at the data inside the images.
            This means that symbols can't be resolved unless you are on the same machine on which you gathered the data.
            
            XPERF solves this problem by adding new 'synthetic' events that it creates by looking at the trace and then
            opening each DLL mentioned and extracting the information needed to look PDBS up on a symbol server (this 
            includes the PE file's TimeDateStamp as well as a PDB Guid, and 'pdbAge' that can be found in the DLLs header.
            
            These new events are added when XPERF runs the 'merge' command (or -d flag is passed).  It is also exposed 
            through the KernelTraceControl.dll!CreateMergedTraceFile API.   
            
            SymbolTraceEventParser is a parser for extra events.   
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.SymbolTraceEventParser.DbgIDRSDS">
            <summary>
             The DbgIDRSDS event is added by XPERF for every Image load.  It contains the 'PDB signature' for the DLL, 
             which is enough to unambigously look the image's PDB up on a symbol server.  
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageID">
            <summary>
            Every DLL has a Timestamp in the PE file itself that indicates when it is built.  This event dumps this timestamp.
            This timestamp is used to be as the 'signature' of the image and is used as a key to find the symbols, however 
            this has mostly be superseeded by the DbgID/RSDS event. 
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.SymbolTraceEventParser.FileVersion">
            <summary>
            The FileVersion event contains information from the file version resource that most DLLs have that indicated
            detailed information about the exact version of the DLL.  (What is in the File->Properties->Version property
            page)
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.SymbolTraceEventParser.None">
            <summary>
            I don't really care about this one, but I need a defintion in order to exclude it because it
            has the same timestamp as a imageLoad event, and two events with the same timestamp confuse the 
            assoication between a stack and the event for the stack.  
            </summary>
        </member>
        <member name="T:Symbols.SymPath">
            <summary>
            SymPath is a class that knows how to parse _NT_SYMBOL_PATH syntax.  
            </summary>
        </member>
        <member name="M:Symbols.SymPath.CleanSymbolPath">
            <summary>
            This 'cleans up' a symbol path.  In particular
            Empty ones are replaced with good defaults (symweb or msdl)
            All symbol server specs have local caches (%Temp%\symbols if nothing else is specified).  
            
            Note that this routine does NOT update _NT_SYMBOL_PATH.  
            </summary>
        </member>
        <member name="M:Symbols.SymPath.InsureHasCache(System.String)">
            <summary>
            People can use symbol servers without a local cache.  This is bad, add one if necessary. 
            </summary>
        </member>
        <member name="M:Symbols.SymPath.LocalOnly">
            <summary>
            Removes all references to remote paths.  This insures that network issues don't cause grief.  
            </summary>
        </member>
        <member name="M:Symbols.SymPath.ComputerNameExists(System.String,System.Int32)">
            <summary>
            Checks to see 'computerName' exists (there is a Domain Names Service (DNS) reply to it)
            This routine times out quickly (after 700 msec).  
            </summary>
        </member>
        <member name="P:Symbols.SymPath.SymbolPath">
            <summary>
            This is the _NT_SYMBOL_PATH exposed as a SymPath type setting this sets the environment variable.
            If you only set _NT_SYMBOL_PATH through the SymPath class, everything stays in sync. 
            </summary>
        </member>
        <member name="P:Symbols.SymPath._NT_SYMBOL_PATH">
            <summary>
            This allows you to set the _NT_SYMBOL_PATH as a string.  
            </summary>
        </member>
        <member name="P:Symbols.SymPath.DefaultSymbolCache">
            <summary>
            If you need to cache files locally, put them here.  It is defined
            to be the first local path of a SRV* qualification or %TEMP%\symbols
            if not is present.
            </summary>
        </member>
        <member name="T:Symbols.SymPathElement">
            <summary>
            SymPathElement is a part of code:SymPath 
            </summary>
        </member>
        <member name="F:Symbols.SymbolReaderNativeMethods.SSRVOPT_DWORD">
                    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
                    public static extern int GetCurrentProcessId();
            
                    [DllImport("kernel32.dll",  SetLastError = true)]
                    public static extern IntPtr OpenProcess(int access, bool inherit, int processID);
                    *
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.KernelTraceEventParser">
            <summary>
            The code:KernelTraceEventParser is a class that knows how to decode the 'standard' kernel events.
            It exposes an event for each event of interest that users can subscribe to.
            
            see code:TraceEventParser for more 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.KernelTraceEventParser.KernelSessionName">
            <summary>
            The special name for the Kernel session
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessStartGroup">
            <summary>
            Registers both ProcessStart and ProcessDCStart
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessEndGroup">
            <summary>
            Registers both ProcessEnd and ProcessDCEnd
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadStartGroup">
            <summary>
            Registers both ThreadStart and ThreadDCStart
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadEndGroup">
            <summary>
            Registers both ThreadEnd and ThreadDCEnd
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageLoadGroup">
            <summary>
            Registers both ImageLoad and ImageDCStart
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageUnloadGroup">
            <summary>
            Registers both ImageUnload and ImageDCEnd
            </summary>
        </member>
        <member name="E:Diagnostics.Tracing.Parsers.KernelTraceEventParser.VolumeMapping">
            <summary>
            File names in ETW are the Kernel names, which need to be mapped to the drive specification users see. 
            This event indicates this mapping. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords">
            <summary>
            This is passed to code:TraceEventSession.EnableKernelProvider to enable particular sets of
            events.  See http://msdn.microsoft.com/en-us/library/aa363784(VS.85).aspx for more information on them 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.None">
            <summary>
            Logs nothing
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskFileIO">
            <summary>
            Logs the mapping of file IDs to actual (kernel) file names. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIO">
            <summary>
            Loads the completion of Physical disk activity. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ImageLoad">
            <summary>
            Logs native modules loads (LoadLibrary), and unloads
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.MemoryHardFaults">
            <summary>
            Logs all page faults that must fetch the data from the disk (hard faults)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.NetworkTCPIP">
            <summary>
            Logs TCP/IP network send and recieve events. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Process">
            <summary>
            Logs process starts and stops.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ProcessCounters">
            <summary>
            Logs process performance counters (TODO When?) (Vista+ only)
            see code:KernelTraceEventParser.ProcessPerfCtr, code:ProcessPerfCtrTraceData
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Profile">
            <summary>
            Sampled based profiling (every msec) (Vista+ only) (expect 1K events per proc per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Thread">
            <summary>
            Logs threads starts and stops
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ContextSwitch">
            <summary>
            log thread context switches (Vista only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIOInit">
            <summary>
            log Disk operations (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (Stacks associated with this)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Dispatcher">
            <summary>
            Thread Dispatcher (ReadyThread) (Vista+ only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIO">
            <summary>
            log file operations when they complete (even ones that do not actually cause Disk I/O).  (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (No stacks associated with these)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIOInit">
            <summary>
            log the start of the File I/O operation as well as the end. (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.MemoryPageFaults">
            <summary>
            Logs all page faults (hard or soft)
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Registry">
            <summary>
            Logs activity to the windows registry. 
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SystemCall">
            <summary>
            log calls to the OS (Vista+ only)
            This is VERY volumous (can be > 100K events per second)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.VirtualAlloc">
            <summary>
            Log Virtual Alloc calls and VirtualFree.   (Vista+ Only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary> 
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.AdvancedLocalProcedureCalls">
            <summary>
            Logs Advanced Local Procedure call events. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DeferedProcedureCalls">
            <summary>
            log defered procedure calls (an Kernel mechanism for having work done asynchronously) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Driver">
            <summary>
            Device Driver logging (Vista+ only)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Interrupt">
            <summary>
            log hardware interrupts. (Vista+ only)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SplitIO">
            <summary>
            Disk I/O that was split (eg because of mirroring requirements) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Default">
            <summary>
            Good default kernel flags.  (TODO more detail)
            </summary>  
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Verbose">
            <summary>
            These events are too verbose for normal use, but this give you a quick way of turing on 'interesting' events
            This does not include SystemCall because it is 'too verbose'
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.TheadTime">
            <summary>
            Use this if you care about blocked time.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.OS">
            <summary>
            You mostly don't care about these unless you are dealing with OS internals.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.All">
            <summary>
            All legal kernel events
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.NonOSKeywords">
            <summary>
            These keywords are can't be passed to the OS, they are defined by KernelTraceEventParser
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.PMCProfile">
            <summary>
            Turn on PMC (Precise Machine Counter) events.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.KernelTraceEventParserState">
            <summary>
            code:KernelTraceEventParserState holds all information that is shared among all events that is
            needed to decode kernel events.   This class is registered with the source so that it will be
            persisted.  Things in here include
            
                * FileID to FileName mapping, 
                * ThreadID to ProcessID mapping
                * Kernel file name to user file name mapping 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.Parsers.KernelTraceEventParserState.threadIDtoProcessIDRundown">
            <summary>
            This is for the circular buffer case.  In that case we may not have thread starts (and thus we don't
            have entries in threadIDtoProcessID).   Because HistoryTable finds the FIRST entry GREATER than the
            given threadID we NEGATE all times before we place it in this table.
            
            Also, because circular buffering is not the common case, we only add entries to this table if needed
            (if we could not find the thread ID using threadIDtoProcessID).  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.KernelToUserDriveMapping">
            <summary>
            Keeps track of the mapping from kernel names to file system names (drives)  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ThreadTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that StartAddr and Win32StartAddr are a code addresses that needs symbolic information
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.CSwitchTraceData.NewThreadID">
            <summary>
            We report a context switch from from the new thread.  Thus NewThreadID == ThreadID.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoTraceData.Irp">
            <summary>
            The I/O Responce Packet address.  This represents the 'identity' of this particular I/O
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoTraceData.DiskServiceTimeMSec">
            <summary>
            This is the actual time the disk spent servicing this IO.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoTraceData.ElapsedTime100ns">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoFlushBuffersTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoFlushBuffersTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.DiskIoFlushBuffersTraceData.ElapsedTime100ns">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.ImageLoadTraceData.BuildTime">
            <summary>
            This is the TimeDateStamp converted to a DateTime
            TODO: daylight savings time seems to mess this up.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.PageFaultTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that ProgramCounter is a code address that needs symbolic information
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.SampledProfileTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.PMCCounterProfTraceData">
            <summary>
            PMC (Precise Machine Counter) events are fired when a CPU counter trips.  The the ProfileSource identifies
            which counter it is.   The PerfInfoCollectionStart events will tell you the count that was configured to trip
            the event.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.PMCCounterProfTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.BatchedSampledProfileTraceData.InstructionPointer(System.Int32)">
            <summary>
            The instruction pointer assocaited with this sample 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.BatchedSampledProfileTraceData.InstanceThreadID(System.Int32)">
            <summary>
            The thread ID associatd with the sample 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.BatchedSampledProfileTraceData.InstanceCount(System.Int32)">
            <summary>
            Each sample may represent mulitiple instances of samples with the same Instruction
            Pointer and ThreadID.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.BatchedSampledProfileTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.BatchedSampledProfileTraceData.BatchCount">
            <summary>
            A BatchedSampleProfile contains many samples in a single payload.  The batchCount
            indicates the number of samples in this payload.  Each sample has a
            InstructionPointer, ThreadID and InstanceCount
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.SysCallEnterTraceData.LogCodeAddresses(System.Func{Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.StackWalkTraceData">
            <summary>
            Collects the call callStacks for some other event.  
            
            (TODO: always for the event that preceeded it on the same thread)?  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.StackWalkTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="i">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.StackWalkTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkTraceData.EventTimeStampRelMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.StackWalkRefTraceData">
            <summary>
            To save space, stack walks in Win8 can be complressed.  The stack walk event only has a 
            reference to a stack Key which is then looked up by StackWalkDefTraceData. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.StackWalkRefTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkRefTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkRefTraceData.EventTimeStampRelMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkRefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.StackWalkDefTraceData">
            <summary>
            This event defines a stack and gives it a unique id (the StackKey), which StackWalkRefTraceData can point at.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.StackWalkDefTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="i">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkDefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkDefTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.StackWalkDefTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.SystemPathsTraceData.SystemDirectory">
            <summary>
            e.g. c:\windows\system32
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.Parsers.SystemPathsTraceData.SystemWindowsDirectory">
            <summary>
            .e.g c:\windows
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.RegisteredTraceEventParser">
            <summary>
            RegisteredTraceEventParser uses the standard windows provider database (what gets registered with wevtutil)
            to find the names of events and fields of the events).   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.ExternalTraceEventParser">
            <summary>
            ExternalTraceEventParser is an abstract class that acts as a parser for any 'External' resolution
            This include the TDH (RegisteredTraceEventParser) as well as the WPPTraceEventParser.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.ExternalTraceEventParser.RegisterTemplate(Diagnostics.Tracing.Parsers.DynamicTraceEventData)">
            <summary>
            Register 'template so that it is known to this TraceEventParser.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.ExternalTraceEventParserState">
            <summary>
            TDHDynamicTraceEventParserState represents the state of a  TDHDynamicTraceEventParser that needs to be
            serialied to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file or the OS TDH APIs.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventID">
            <summary>
            Individual event providers can supply many different types of events.  These are distinguished from each
            other by a TraceEventID, which is just a 16 bit number.  Its meaning is provider-specific.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventChannel">
            <summary>
            Providers can define different audiences or Channels for an event (eg Admin, Developer ...) Its
            meaning is provider 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventOpcode">
            <summary>
            There are certain classes of events (like start and stop) which are common across a broad variety of
            event providers for which it is useful to treat uniformly (for example, determing the elapsed time
            between a start and stop event).  To facilitate this, event can have opcode which defines these
            common operations.  Below are the standard ones but proivders can define additional ones about 10.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.Info">
            <summary>
            Generic opcode that does not have specific semantics associted with it. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.Start">
            <summary>
            The entity (process, thread, ...) is starting
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.Stop">
            <summary>
            The entity (process, thread, ...) is stoping (ending)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.DataCollectionStart">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.DataCollectionStop">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time. This is mostly for 'flight recorder' scenarios where
            you only have the 'tail' of the data and would like to know about everything that existed. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventOpcode.Extension">
            <summary>
            TODO document these. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventKeyword">
            <summary>
            VISTA ETW defines the concept of a Keyword, which is a 64 bit bitfield. Each bit in the bitfield
            represents some proider defined 'area' that is useful for filtering. When processing the events, it
            is then possible to filter based on whether various bits in the bitfield are set.  There are some
            standard keywords, but most are provider specific. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventTask">
            <summary>
            Tasks are groups of related events for a given provider (for example Process, or Thread, or Registry
            for the Kernel Provider).  They are defined by the provider.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.EventIndex">
            <summary>
            code:EventIdex is a unsigned integer that is unique to a particular event. Like code:ProcessIndex and
            code:ThreadIndex, code:EventIndex is guarenteed to be unique over the whole log.  
            
            The fact that EventIndex is a 32 bit number limits us to 4Gig events in a log.  Sample based profiling
            takes 1K samples per CPU per second.  Context switches and page faults can happen at about the same
            rate.  Thus 3K-6K is not uncommon and 10K /sec.  At that rate it will take 4E5 seconds == 111 hours
            == 4.6 days to exceed the limit.  Even at 100K / sec, it would be 11 hours of trace (Keep in mind
            we don't give StackTrace events IDs).   The file size would be greater than 100Gig which would make
            it REALLY painful to work with.  
            
            We choose as the event ID simply the index in the log file of the event.  Thus the IDs are dense as
            they can be.  We don't however guarentee ordering, as we probably want to be able to add new
            events to the stream, and these will be addded at the end even if they occur elsewhere in the time
            stream. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.EmptyTraceData">
            <summary>
            When the event has no interesting data associated with it, you can use this shared event current
            rather than making an event-specific class.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Int32TraceData">
            <summary>
            When the event has just a single int value associated with it, you can use this shared event current
            rather than making an event-specific class.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Int64TraceData">
            <summary>
            When the event has just a single int value associated with it, you can use this shared event current
            rather than making an event-specific class.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StringTraceData">
            <summary>
            When the event has just a single string value associated with it, you can use this shared event
            template rather than making an event-specific class.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.UnhandledTraceEvent.PrepForCallback">
            <summary>
            There is some work needed to prepare the generic unhandledTraceEvent that we defer
            late (since we often don't care about unhandled events)  
            
            TODO this is probably not worht the complexity...
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods">
            <summary>
            TraceEventNativeMethods contains the PINVOKE declarations needed
            to get at the Win32 TraceEvent infrastructure.  It is effectively
            a port of evntrace.h to C# declarations.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.SetSystemProfilePrivilege">
            <summary>
            The Sample based profiling requires the SystemProfilePrivilege, This code turns it on.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.TIME_ZONE_INFORMATION">
            <summary>
            Time zone info.  Used as one field of TRACE_EVENT_LOGFILE, below.
            Total struct size is 0xac.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.WNODE_HEADER">
            <summary>
            EventTraceHeader structure used by EVENT_TRACE_PROPERTIES
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES">
            <summary>
            EVENT_TRACE_PROPERTIES is a structure used by StartTrace, ControlTrace
            however it can not be used directly in the defintion of these functions
            because extra information has to be hung off the end of the structure
            before beinng passed.  (LofFileNameOffset, LoggerNameOffset)
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_TRACE_HEADER">
            <summary>
            EventTraceHeader and structure used to defined EVENT_TRACE (the main packet)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_TRACE">
            <summary>
            EVENT_TRACE is the structure that represents a single 'packet'
            of data repesenting a single event.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.TRACE_LOGFILE_HEADER">
            <summary>
            TRACE_LOGFILE_HEADER is a header used to define EVENT_TRACE_LOGFILEW.
            Total struct size is 0x110.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_TRACE_LOGFILEW">
            <summary>
            EVENT_TRACE_LOGFILEW Main struct passed to OpenTrace() to be filled in.
            It represents the collection of ETW events as a whole.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_HEADER">
            <summary>
            EventTraceHeader and structure used to define EVENT_TRACE_LOGFILE (the main packet on Vista and above)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.ETW_BUFFER_CONTEXT">
            <summary>
            Provides context information about the event
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_RECORD">
            <summary>
            Defines the layout of an event that ETW delivers
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.TraceEventNativeMethods.STACK_TRACING_EVENT_ID">
            <summary>
            Used in code:StartKernelTrace to indicate the kernel events that should have stack traces
            collected for them.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventSession">
            <summary>
            #Introduction 
            
            A TraceEventSession represents a single ETW Tracing Session (something that logs a
            single output moduleFile). Every ETL output moduleFile has exactly one session assoicated with it,
            although you can have 'real time' sessions that have no output file and you can connect to
            'directly' to get events without ever creating a file. You signify this simply by passing
            'null' as the name of the file. You extract data from these 'real time' sources by specifying
            the session name to the constructor of code:ETWTraceEventSource). Sessions are MACHINE WIDE and can
            OUTLIVE the process that creates them. This it takes some care to insure that sessions are cleaned up
            in all cases.
            
            Code that generated ETW events are called Providers. The Kernel has a provider (and it is often the
            most intersting) but other components are free to use public OS APIs (eg WriteEvent), to create
            user-mode providers. Each Provider is given a GUID that is used to identify it. You can get a list of
            all providers on the system as well as their GUIDs by typing the command
            
                        logman query providers
                        
            The basic model is that you start a session (which creates a ETL moduleFile), and then you call
            code:TraceEventSession.EnableProvider on it to add all the providers (event sources), that you are
            interested in. A session is given a name (which is MACHINE WIDE), so that you can connect back up to
            it from another process (since it might outlive the process that created it), so you can modify it or
            (more commonly) close the session down later from another process.
            
            For implementation reasons, this is only one Kernel provider and it can only be specified in a
            special 'Kernel Mode' session. There can be only one kernel mode session (MACHINE WIDE) and it is
            distinguished by a special name 'NT Kernel Logger'. The framework allows you to pass flags to the
            provider to control it and the Kernel provider uses these bits to indicate which particular events
            are of interest. Because of these restrictions, you often need two sessions, one for the kernel
            events and one for all user-mode events.
            
            Sample use. Enabling the Kernel's DLL image logging to the moduleFile output.etl
            
             * TraceEventSession session = new TraceEventSession(, KernelTraceEventParser.Keywords.ImageLoad); 
             * Run you scenario 
             * session.Close(); 
            
            Once the scenario is complete, you use the code:TraceEventSession.Close methodIndex to shut down a
            session. You can also use the code:TraceEventSession.GetActiveSessionNames to get a list of all
            currently running session on the machine (in case you forgot to close them!).
            
            When the sesion is closed, you can use the code:ETWTraceEventSource to parse the events in the ETL
            moduleFile.  Alternatively, you can use code:TraceLog.CreateFromETL to convert the ETL file into an ETLX file. 
            Once it is an ETLX file you have a much richer set of processing options availabe from code:TraceLog. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.#ctor(System.String,System.String)">
            <summary>
            Create a new logging session.
            </summary>
            <param name="sessionName">
            The name of the session. Since session can exist beyond the lifetime of the process this name is
            used to refer to the session from other threads.
            </param>
            <param name="fileName">
            The output moduleFile (by convention .ETL) to put the event data. If this parameter is null, it means
            that the data is 'real time' (stored in the session memory itself)
            </param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.#ctor(System.String)">
            <summary>
            Open an existing Windows Event Tracing Session, with name 'sessionName'. To create a new session,
            use TraceEventSession(string, string)
            </summary>
            <param name="sessionName"> The name of the session to open (see GetActiveSessionNames)</param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.EnableKernelProvider(Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords)">
            <summary>
            #EnableKernelProvider
            Enable the kernel provider for the session. If the session must be called 'NT Kernel Session'.   
            <param name="flags">
            Specifies the particular kernel events of interest</param>
            <param name="stackCapture">
            Specifies which events should have their eventToStack traces captured too (VISTA+ only)</param>
            <returns>Returns true if the session had existed before and is now restarted</returns>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Diagnostics.Tracing.TraceEventSession.GetEventSourceGuidFromName(System.String)" -->
        <member name="M:Diagnostics.Tracing.TraceEventSession.EnableProvider(System.Guid,Diagnostics.Tracing.TraceEventLevel,System.UInt64,System.UInt64,Diagnostics.Tracing.TraceEventOptions,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add an additional USER MODE provider prepresented by 'providerGuid' (a list of
            providers is available by using 'logman query providers').
            </summary>
            <param name="providerGuid">
            The GUID that represents the event provider to turn on. Use 'logman query providers' or
            for a list of possible providers. Note that additional user mode (but not kernel mode)
            providers can be added to the session by using EnableProvider.</param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usuall 'everything'</param>
            <param name="matchAllKeywords">A bitvector representing keywords of an event that must
            be on for a particular event for the event to be logged.  A value of zero means
            that no keyword must be on, which effectively ignores this value.  </param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace)</param>
            <param name="values">This is set of key-value strings that are passed to the provider
            for provider-specific interpretation. Can be null if no additional args are needed.  
            If the special key-value pair 'Command'='SendManifest' is provided, then the 'SendManifest'
            command will be sent (which causes EventSources to redump their manifest to the ETW log.  </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.DisableProvider(System.Guid)">
            <summary>
            Disables a provider completely
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.Stop(System.Boolean)">
            <summary>
            Once started, event sessions will persist even after the process that created them dies. They are
            only stoped by this explicit Stop() API. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.CaptureState(System.Guid,System.UInt64,System.Int32,System.Object)">
            <summary>
            Sends the CAPUTURE_STATE command to the provider 
            
            This routine only works Win7 and above, since previous versions don't have this concept.   The providers also has 
            to support it.  
            
            You can use KernelTraceEventParser.ProviderGuid here to cause rundown for the system.  
            </summary>
            <param name="providerGuid">The GUID that identifies the provider to send the CaptureState command to</param>
            <param name="matchAnyKeywords">The Keywords to send as part of the command (can influnced what is sent back)</param>
            <param name="filterType">if non-zero, this is passed along to the provider as type of the filter data.</param>
            <param name="data">If non-null this is either an int, or a byte array and is passed along as filter data.</param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.EnableWindowsHeapProvider(System.Int32)">
            <summary>
            Turn on windows heap logging (stack for allocation) for a particular existing process.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.EnableWindowsHeapProvider(System.String)">
            <summary>
            Turn on windows heap logging for a particular EXE file name (just the file name, no directory, but it DOES include the .exe extension)
            </summary>
            <param name="exeFileName"></param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.GetProfileSourceInfo">
            <summary>
            Returns a ditionary of keyed by name of ProfileSourceInfo structures for all the CPU counters available on the machine. 
            TODO FIX NOW remove log parameter. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.SetProfileSources(System.Int32[],System.Int32[])">
            <summary>
            Sets the Profile Sources (CPU machine counters) that will be used if PMC (Precise Machine Counters)
            are turned on.   Each CPU counter is given a id (the profileSourceID) and has an interval 
            (the number of counts you skip for each event you log).   You can get the human name for 
            all the supported CPU counters by calling GetProfileSourceInfo.  Then choose the ones you want
            and configure them here (the first array indicating the CPU counters to enable, and the second
            array indicating the interval.  The second array can be shorter then the first, in which case
            the existing interval is used (it persists and has a default on boot).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.Merge(System.String[],System.String)">
            <summary>
            It is sometimes useful to merge the contents of several ETL files into a single 
            output ETL file.   This routine does that.  It also will attach additional 
            information that will allow correct file name and symbolic lookup if the 
            ETL file is used on a machine other than the one that the data was collected on.
            If you wish to transport the file to another machine you need to merge them.
            </summary>
            <param name="inputETLFileNames"></param>
            <param name="outputETLFileName"></param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.MergeInPlace(System.String,System.IO.TextWriter)">
            <summary>
            This variation of the Merge command takes the 'primary' etl file name (X.etl)
            and will merge in any files that match .clr*.etl .user*.etl. and .kernel.etl.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.GetActiveSessionNames">
            <summary>
            ETW trace sessions survive process shutdown. Thus you can attach to existing active sessions.
            GetActiveSessionNames() returns a list of currently existing session names.  These can be passed
            to the code:TraceEventSession constructor to control it.   
            </summary>
            <returns>A enumeration of strings, each of which is a name of a session</returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.ProvidersInProcess(System.Int32)">
            <summary>
            Returns a list of provider GUIDs that are registered in a process with 'processID'.   
            This is a nice way to filter down the providers you might care about. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.GetProviderByName(System.String)">
            <summary>
            Given the friendly name of a provider (e.g. Microsoft-Windows-DotNETRuntimeStress) return the
            GUID for the provider.  Returns Guid.Empty on failure.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.GetProviderName(System.Guid)">
            <summary>
            Finds the friendly name for 'providerGuid'  Returns the Guid as a string if can't be found
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.GetProviderKeywords(System.Guid)">
            <summary>
            Returns the keywords the provider represented by 'providerGuid' supports. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.IsElevated">
            <summary>
            Is the current process Elevated (allowed to turn on a ETW provider).   Does not really belong here
            but it useful since ETW does need to be elevated.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.StartKernelTrace(System.UInt64@,Diagnostics.Tracing.Parsers.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES*,Diagnostics.Tracing.Parsers.TraceEventNativeMethods.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            We wrap this because sadly the PMC suppport is private, so we have to do it a different way if that is present.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.Finalize">
            <summary>
            The 'properties' field is only the header information.  There is 'tail' that is 
            required.  'ToUnmangedBuffer' fills in this tail properly. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.EnableProvider(System.Guid,Diagnostics.Tracing.TraceEventLevel,System.UInt64,System.UInt64,Diagnostics.Tracing.TraceEventOptions,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Do intialization common to the contructors.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventSession.SetStackTraceIds(Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Diagnostics.Tracing.Parsers.TraceEventNativeMethods.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            Given a mask of kernel flags, set the array stackTracingIds of size stackTracingIdsMax to match.
            It returns the number of entries in stackTracingIds that were filled in.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.CircularBufferMB">
            <summary>
            Cause the log to be a circular buffer.  The buffer size (in MegaBytes) is the value of this property.
            Setting this to 0 will cause it to revert to non-circular mode.  This routine can only be called BEFORE
            a provider is enabled.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.BufferSizeMB">
            <summary>
            Sets the size of the buffer the operating system should reserve to avoid lost packets.   Starts out 
            as a very generous 32MB for files.  If events are lost, this can be increased.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.StopOnDispose">
            <summary>
            If set then Stop() will be called automatically when this object is Disposed or GCed (which
            will happen on program exit unless a unhandled exception occurs.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.SessionName">
            <summary>
            The name of the session that can be used by other threads to attach to the session. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.FileName">
            <summary>
            The name of the moduleFile that events are logged to.  Null means the session is real time. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.IsActive">
            <summary>
            Creating a TraceEventSession does not actually interact with the operating system until a
            provider is enabled. At that point the session is considered active (OS state that survives a
            process exit has been modified). IsActive returns true if the session is active.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.CpuSampleIntervalMSec">
            <summary>
            The rate at which CPU samples are collected.  By default this is 1 (once a millisecond per CPU).
            There is alower bound on this (typically .125 Msec)
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.StackCompression">
            <summary>
            Indicate that this session should use compress the stacks to save space.  
            Must be set before any providers are enabled.  Currently only works for kernel events.  
            TODO FIX NOW untested.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.RegisteredProviders">
            <summary>
            Returns the names of every registered provider on the system.   This is a long list (1000s of entries.  
            You can get its Guid with GetProviderByName.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventSession.ProviderNameToGuid">
            <summary>
            Returns a sorted dictionary of  names and Guids for every provider registered on the system.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventSession.ProfileSourceInfo">
            <summary>
            Returned by GetProfileSourceInfo, describing the CPU counter (ProfileSource) available on the machine. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.ProviderDataItem">
            <summary>
            A list of these is returned by GetProviderKeywords
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventOptions">
            <summary>
            These are options to EnableProvider
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventLevel">
            <summary>
            Indicates to a provider whether verbose events should be logged.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventStackSource">
            <summary>
            This is the traditional grouping by method.
            
            TraceEventStackSource create the folowing meaning for the code:StackSourceCallStackIndex
            
            * The call stacks ID consists of the following ranges concatinated together. 
                * a small set of fixed Pseuo stacks (Start marks the end of these)
                * CallStackIndex
                * ThreadIndex
                * ProcessIndex
                * BrokenStacks (One per thread)
                * Stacks for threads without explicit stacks (Limited to 1K)
                    
            TraceEventStackSource create the folowing meaning for the code:StackSourceFrameIndex
            
            The frame ID consists of the following ranges concatinated together. 
                * a small fixed number of Pseudo frame (Broken, and Unknown)
                * MaxCodeAddressIndex - something with a TraceCodeAddress. 
                * ThreadIndex         - ETW stacks don't have a thread or process node, so we add them.
                * ProcessIndex
                
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventStackSource.LookupWarmSymbols(System.Int32,Symbols.SymbolReader,Diagnostics.Tracing.StackSources.StackSource)">
            <summary>
            Looks up symbols for all modules that have an inclusive count >= minCount. 
            stackSource, if given, can be used to be the filter.  If null, 'this' is used.
            If stackSource is given, it needs to use the same indexes for frames as 'this'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventStackSource.GetFrameCodeAddress(Diagnostics.Tracing.StackSources.StackSourceFrameIndex)">
            <summary>
            Given a frame index, return the cooresponding code address for it. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventStackSource.GetModulesForStack(Diagnostics.Tracing.TraceEventStackSource.ModuleList[],Diagnostics.Tracing.StackSources.StackSourceCallStackIndex)">
            <summary>
            Returns a list of modules for the stack 'stackIdx'.  It also updates the interning table stackModuleLists, so 
            that the entry cooresponding to stackIdx remembers the answer.  This can speed up processing alot since many
            stacks have the same prefixes to root.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceEventStackSource.m_pseudoStacksTable">
            <summary>
            This maps pseudo-stacks to their index (thus it is the inverse of m_pseudoStack; 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventStackSource.GetPseudoStack(Diagnostics.Tracing.ThreadIndex,Diagnostics.Tracing.CodeAddressIndex)">
            <summary>
            Given a thread and a call stack that does not have a stack, make up a pseudo stack for it consisting of the code address, 
            the broken node, the thread and process.   Will return -1 if it can't allocate another Pseudo-stack.
            </summary> 
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventStackSource.TraceLog">
            <summary>
            Return the TraceLog file that is associated with this stack source.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEventStackSource.ShowUnknownAddresses">
            <summary>
            Normally addresses without symbolic names are listed as ?, however sometimes it is useful 
            to see the actuall address as a hexidecimal number.  Setting this will do that.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventStackSource.ModuleList">
            <summary>
            A ModuleList is a linked list of modules.  It is only used in GetModulesForStack and LookupWarmSymbols
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.InternTraceEventStackSource">
            <summary>
            InternTraceEventStackSource works much like TraceEventStackSource.   What is different is
            that like all InternStackSources it copies out all the information from the original source
            to lookup its frames.  This makes it easy to add new 'psedudo' frames (typically at the top
            or the bottom of the stack), and thus is useful for views where you wish to do this.  The
            disadvantage of this is that you do need to compute all symbolic information before you 
            create the source (since changing symbols will invalidate the interning).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.InternTraceEventStackSource.GetCallStack(Diagnostics.Tracing.CallStackIndex,Diagnostics.Tracing.TraceEvent)">
            <summary>
            Convert the TraceEvent callStack 'callStackIdx' into a StackSourceCallStack.  'callStackIdx is 
            assumed to be related to the traceEvent 'data'.   'data' is used to determine the process and thread
            of the stack.  (TODO data may not be needed anymore as callStackIndexes do encode their thread (and thus process)). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.InternTraceEventStackSource.GetCallStack(Diagnostics.Tracing.CallStackIndex,Diagnostics.Tracing.StackSources.StackSourceCallStackIndex,System.Collections.Generic.Dictionary{System.Int32,Diagnostics.Tracing.StackSources.StackSourceCallStackIndex})">
            <summary>
            Find the StackSourceCallStackIndex for the TraceEvent call stack index 'callStackIndex' which has a top of its 
            stack as 'top'.  If callStckMap is non-null it is used as an interning table for CallStackIndex -> StackSourceCallStackIndex.
            This can speed up the transformation dramatically.  
            </summary>
            <param name="callStackIndex"></param>
            <param name="top"></param>
            <param name="callStackMap"></param>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.InternTraceEventStackSource.SortSamples">
            <summary>
            This is only used for ETW unmanaged memory collection.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.InternTraceEventStackSource.ShowUnknownAddressses">
            <summary>
            Normally addresses without symbolic names are listed as ?, however sometimes it is useful 
            to see the actuall address as a hexidecimal number.  Setting this will do that.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.MutableTraceEventStackSource">
            <summary>
            A MutableTraceEventStackSource allows you to create new nodes on the fly as well as add samples
            However unlike an InternStackSource, it keeps the identity of the Stacks and Frames that came
            from the TraceLog (thus things like GetSourceLine and LookupSymbols work).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.AddSample(Diagnostics.Tracing.StackSources.StackSourceSample)">
            <summary>
            After creating a MultableTraceEventStackSource, you add the samples you want and then call DoneAddingSamples
            From that point on you have a fine, read-only stacks source.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetFrameIndexForName(System.String,Diagnostics.Tracing.StackSources.StackSourceModuleIndex)">
            <summary>
            Create a new frame out of 'nothing' (just its name) and optionaly a module
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetFrameIndexDerivedFrame(Diagnostics.Tracing.StackSources.StackSourceFrameIndex,System.String)">
            <summary>
            If you wish to make a frame by annotatting another frame, you can use this method.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetFrameIndex(Diagnostics.Tracing.CodeAddressIndex)">
            <summary>
            Create a frame name from a TraceEvent code address.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetCallStack(Diagnostics.Tracing.StackSources.StackSourceFrameIndex,Diagnostics.Tracing.StackSources.StackSourceCallStackIndex)">
            <summary>
            Create a new stack out of 'nothing' just a frame and the caller.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetCallStackForProcess(Diagnostics.Tracing.TraceProcess)">
            <summary>
            Get the call stack representing a TraceEvent process
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetCallStackForThread(Diagnostics.Tracing.TraceThread)">
            <summary>
            Get the call stack representing a TraceEvent thread 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.MutableTraceEventStackSource.GetCallStack(Diagnostics.Tracing.CallStackIndex,Diagnostics.Tracing.StackSources.StackSourceCallStackIndex,System.Collections.Generic.Dictionary{System.Int32,Diagnostics.Tracing.StackSources.StackSourceCallStackIndex})">
            <summary>
            Find the StackSourceCallStackIndex for the TraceEvent call stack index 'callStackIndex' which has a top of its 
            stack as 'top'.  If callStckMap is non-null it is used as an interning table for CallStackIndex -> StackSourceCallStackIndex.
            This can speed up the transformation dramatically.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLog">
            <summary>
            #Introduction
            
            While the raw ETW events are valuable, they really need additional processing to be really useful.
            Things like symbolic names for addresses, the ability to randomly access events, and having various
            links between threads, threads, modules, and eventToStack traces are really needed. This is what
            code:TraceLog provides.
            
            In addition the format of an ETL file is private (it can only be accessed through OS APIs), and the
            only access is as stream of records. This makes it very difficult to do processing on the data
            without reading all the data into memory or reading over the file more than once. Because the data is
            very large, this is quite undesireable. There is also no good place to put digested information like
            symbols, or indexes. code:TraceLog also defines a new file format for trace data, that is public and
            seekable, extendable, and versionable. This is a key piece of added value.
            
            code:TraceLog is really the entry point for a true object model for event data that are cross linked
            to each other as well as the raw events. Here are some of the players
            
            * code:TraceLog - represents the event log as a whole. It holds 'global' things, like a list of
                code:TraceProcesss, and the list of code:TraceModuleFiles
                * code:TraceProcesses - represents a list of code:TraceProcess s, that can be looked up by
                    (PID,time)
                * code:TraceProcess - represents a single process.
                * code:TraceThread - reprsents a thread within a process.
                * code:TraceLoadedModules - represents a list of code:TraceLoadedModule s that can be looked up
                    by (address, time) or (filename, time)
                * code:TraceLoadedModule - represents a loaded DLL or EXE (it knows its image base, and time
                    loaded)
                * code:TraceModuleFile - represents a DLL or EXE on the disk (it only contains information that
                    is common to all threads that use it (eg its name). In particular it holds all the symbolic
                    address to name mappings (extracted from PDBs).  New TraceModuleFiles are generated if a
                    files is loaded in another locations (either later in the same process or a different
                    process).   Thus the image base becomes a attribute of the ModuleFile
                * code:TraceCallStack - represents a call stack associated with the event (on VISTA). It is
                    logically a list of code addresses (from callee to caller).    
                * code:TraceCodeAddress - represents instruction pointer into the code. This can be decorated
                    with symbolic information, (methodIndex, source line, source file) information.
                * code:TraceMethod - represents a particular method.  This class allows information that is
                    common to many samples (it method name and source file), to be shared.  
                
            * See also code:TraceLog.CopyRawEvents for the routine that scans over the events during TraceLog
                creation.
            * See also code:#ProcessHandlersCalledFromTraceLog for callbacks made from code:TraceLog.CopyRawEvents
            * See also code:#ModuleHandlersCalledFromTraceLog for callbacks made from code:TraceLog.CopyRawEvents
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializableVersion">
            <summary>
            Objects implement code:IFastSerializableVersion to indicate what the current version is for writing
            and which readers can read the curent version.   If this interface is not implemented a default is
            provided (assuming version 1 for writing and MinimumVersion = 0).  
            
            By default code:Serializer.WriteObject will place marks when the object ends and always skip to the
            end even if the FromStream did not read all the object data.   This allows considerable versioning
            flexibilty.  Simply by placing the new data at the end of the existing serialization, new versions
            of the type can be read by OLD deserializers (new fields will have the value determined by the
            default constructor (typically 0 or null).  This makes is relatively easy to keep MinimumVersion = 0
            (the ideal case).  
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.Version">
            <summary>
            This is the version number for the serialization format.  It should be incremented whenever a
            changes is made to code:IFastSerializable.ToStream and the format is publicly diseminated.  It
            must not vary from instance to instance.  This is pretty straightforward.  
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumVersionCanRead">
             <summary>
             At some point typically you give up allowing new versions of the read to read old wire formats
             This is the Minimum version of the serialized data that this reader can deserialize.   Trying
             to read wire formats strictly smaller (older) than this will fail.   Setting this to the current
             version indicates that you don't care about ever reading data generated with an older version
             of the code.  
             
             If you set this to something other than your current version, you are obligated to insure that
             your FromStream() method can handle all formats >= than this number. 
            
             You can achive this if you simply use the 'WriteTagged' and 'ReadTagged' APIs in your 'ToStream' 
             and 'FromStream' after your V1 AND you always add new fields to the end of your class.   
             This is the best practice.   Thus  
             
                 void IFastSerializable.ToStream(Serializer serializer)
                 {
                     serializer.Write(Ver_1_Field1);
                     serializer.Write(Ver_1_Field2);
                     // ...
                     serializer.WriteTagged(Ver_2_Field1);   
                     serializer.WriteTagged(Ver_2_Field2);
                     // ...
                     serializer.WriteTagged(Ver_3_Field1);
                 }
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     deserializer.Read(out Ver_1_Field1);
                     deserializer.Read(out Ver_1_Field2);
                     // ...
                     deserializer.ReadTagged(ref Ver_2_Field1);  // If data no present (old format) then Ver_2_Field1 not set.
                     deserializer.ReadTagged(ref Ver_2_Field2);  // ditto...
                     // ...
                     deserializer.ReadTagged(ref Ver_3_Field1);    
                 } 
             
             Tagging outputs a byte tag in addition to the field itself.   If that is a problem you can also use the
             VersionBeingRead to find out what format is being read and write code that explicitly handles it.  
             Note however that this only gets you Backward compatibility (new readers can read the old format, but old readers 
             will still not be able to read the new format), which is why this is not the preferred method.  
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     // We assme that MinVersionCanRead == 4
                     // Deserialize things that are common to all versions (4 and earlier) 
                     
                     if (deserializer.VersionBeingRead >= 5)
                     {
                         deserializer.Read(AVersion5Field);
                         if (deserializer.VersionBeingRead >= 5)
                             deserializer.ReadTagged(AVersion6Field);    
                     }
                 }
             </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumReaderVersion">
            <summary>
            This is the minimum version of a READER that can read this format.   If you don't support forward
            compatibilty (old readers reading data generated by new readers) then this should be set to 
            the current version.  
            
            If you set this to something besides the current version you are obligated to insure that your
            ToStream() method ONLY adds fields at the end, AND that all of those added fields use the WriteTagged()
            operations (which tags the data in a way that old readers can skip even if they don't know what it is)
            In addition your FromStream() method must read these with the ReadTagged() deserializer APIs.  
            
            See the comment in front of MinimumVersionCanRead for an example of using the WriteTagged() and ReadTagged() 
            methods. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.OpenOrConvert(System.String,Diagnostics.Tracing.TraceLogOptions)">
            <summary>
            If etlxFilePath exists, it simply calls the constuctor.  However it it does not exist and a
            cooresponding ETL file exists, generate the etlx file from the ETL file.  options indicate
            conversion options (can be null). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.#ctor(System.String)">
            <summary>
            Opens a existing Trace Event log file (and ETLX file).  If you need to create a new log file
            from other data see 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CreateFromETL(System.String)">
            <summary>
            Generates the cooresponding ETLX file from the raw ETL files.  Returns the name of ETLX file. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CreateFromETL(System.String,System.String,Diagnostics.Tracing.TraceLogOptions)">
            <summary>
            Given 'etlFilePath' create a etlxFile for the profile data. Options can be null.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CreateFromSource(Diagnostics.Tracing.TraceEventDispatcher,System.String,Diagnostics.Tracing.TraceLogOptions)">
            <summary>
            Given a source of events 'source' generated a ETLX file representing these events from them. This
            file can then be opened with the code:TraceLog constructor. 'options' can be null.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CreateFromSourceTESTONLY(Diagnostics.Tracing.TraceEventDispatcher,System.String,Diagnostics.Tracing.TraceLogOptions)">
            <summary>
            TODO: only used for testing, will be removed eventually.  Use CreateFromSource
            
            Because the code path when reading from the file (and thus uses the deserializers), is very
            different from when the data structures are in memory, and we don't want to have to test both
            permutations, we don't allow getting a TraceLog that did NOT come from a file.  
            
            However for testing this is useful, because we can see the 'before serialization' and 'after
            serialization' behavior and if they are differnet we know we hav a bug.  This routine should be
            removed eventually, after we have high confidence that the log file works well.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.GetCallStackForEvent(Diagnostics.Tracing.TraceEvent)">
            <summary>
            If the event has a call eventToStack associated with it, retrieve it. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.GetCodeAddressAtEvent(System.UInt64,Diagnostics.Tracing.TraceEvent)">
            <summary>
            If an event has fields of type 'Address' the address can be converted to a symblic value (a
            code:TraceCodeAddress) by calling this function.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.GetEvent(Diagnostics.Tracing.EventIndex)">
            <summary>
            Given an eventIndex, get the event.  This is relatively expensive because we need to create a
            copy of the event that will not be reused by the TraceLog.   Ideally you woudld not use this API
            but rather use iterate over event using code:TraceEvents
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.Close">
            <summary>
            Agressively releases resources associated with the log. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CopyRawEvents(Diagnostics.Tracing.TraceEventDispatcher,FastSerialization.IStreamWriter)">
            <summary>
             Copies the events from the 'rawEvents' dispatcher to the output stream 'IStreamWriter'.  It
             also creates auxillery data structures associated with the raw events (eg, processes, threads,
             modules, address lookup maps...  Basically any information that needs to be determined by
             scanning over the events during TraceLog creation should hook in here.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.EmitStackForEventIfReady(Diagnostics.Tracing.TraceLog.EventStackInfo,System.Boolean)">
            <summary>
            Determine if 'stackInfo' is complete and if so emit it to the 'eventsToStacks' array.  If 'force' is true 
            then force what information there is out even if it is not complete (there is nothing else comming). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.CategorizeThread(Diagnostics.Tracing.TraceEvent,System.String)">
            <summary>
            Put the thread that owns 'data' in to the cateory 'category.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.ProcessExtendedData(Diagnostics.Tracing.TraceEvent,System.UInt16,Diagnostics.Tracing.TraceEventCounts)">
            <summary>
            Process any extended data (like Win7 style stack traces) associated with 'data'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.SeekToTimeOnPage(FastSerialization.PinnedStreamReader,System.Int64,System.Int32,System.Int32@,FastSerialization.StreamLabel[])">
            <summary>
            Advance 'reader' until it point at a event that occurs on or after 'time100ns'.  on page
            'pageIndex'.  If 'positions' is non-null, fill in that array.  Also return the index in
            'positions' for the entry that was found.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Events">
            <summary>
            All the events in the stream.  A code:TraceEvent can be used with foreach
            directly but it can also be used to filter in arbitrary ways to form other
            logical streams of data.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Processes">
            <summary>
            Enumerate all the processes that occured in the trace log. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Threads">
            <summary>
            Enumerate all the threads that occured in the trace log.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.ModuleFiles">
            <summary>
            A list of all the files that are loaded by some process during the logging. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.CallStacks">
            <summary>
            Get the collection of all callstacks.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.CodeAddresses">
            <summary>
            Get the collection of all symbolic code addresses. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Stats">
            <summary>
            Has summary statistics on the events in the log.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.MaxEventIndex">
            <summary>
            Events are given an Index (ID) that are unique across the whole code:TraceLog.   They are not guarenteed
            to be sequential, but they are guarenteed to be between 0 and MaxEventIndex.  Ids can be used to
            allow clients to associate additional information with event (with a side lookup table).   See
            code:TraceEvent.EventIndex and code:EventIndex for more 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Size">
            <summary>
            The size of the log file.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.EventCount">
            <summary>
            The total number of events in the log.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.FilePath">
            <summary>
            The file path name for the ETLX file associated with this log.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.MachineName">
            <summary>
            The machine one which the log was collected.  Returns empty string if unknown. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.OSName">
            <summary>
            The name of the Operating system.  Return empty string if unknown
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.OSBuild">
            <summary>
            The build number information for the OS.  Return empty string if unknown
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.BootTime">
            <summary>
            The time the machine was booted (note it can be 0 if we don't know)
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.HasPdbInfo">
            <summary>
            Returns true if the log has information necessary to look up PDBS associated with the images
            in the trace.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.MemorySizeMeg">
            <summary>
            The size of the main memory (RAM) on the collection machine.  Will return 0 if memory size is unknown 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.HasCallStacks">
            <summary>
            Are there any events with stack traces in them?
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLog.Parsers">
            <summary>
            Returns all the TraceEventParsers associated with this log.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLog.EventStackInfo">
            <summary>
            Holds information Stacks associated with an event.  THis is a transient strucutre.  We only need it 
            until all the information is collected for a particular event, at which point we can create a 
            CallStackIndex for the stack and eventsToStacks table.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLog.PastEventInfo">
            <summary>
            We need to remember the the EventIndexes of the events that were 'just before' this event so we can
            associate eventToStack traces with the event that actually caused them.  PastEventInfo does this.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.PastEventInfo.GetNextEventIndex(Diagnostics.Tracing.TraceLog.PastEventInfoIndex,System.Int32)">
            <summary>
            Searches forward in time (until the current time) after 'eventIndex'
            for events on 'threadID'.   Returns PastEventInfoIndex.Invalid if there are none
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLog.PastEventInfo.GetNextEvent(Diagnostics.Tracing.TraceLog.PastEventInfoIndex,System.Int32)">
            <summary>
            Gets the next event between index and now that has a matching 'threadID'.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEventStats.GetEventCounts(Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given an event 'data' look up the statistics for events that type.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceEventCounts">
            <summary>
            TraceEventCounts remembers some statistics about a particular event type.
            An event is determined by its ETW identity (provider guid and event id for
            manifest, task-opcode for classic).   This structure looks up the guid
            LAZILY to find the name, which means it is the providers at USE time
            not COLLECTION time that determine if names are found.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvents.FilterByTime(System.DateTime,System.DateTime)">
            <summary>
            Filter the events by time.  both startime and endTime are INCLUSIVE. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvents.FilterByTime(System.Double,System.Double)">
            <summary>
            Filters by time expressed as MSec from the start of the trace. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceEvents.FilterByTime(System.Int64,System.Int64)">
            <summary>
            Filter the events by time.  both startTime100ns and endTime100ns are INCLUSIVE. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceEvents.StartTime100ns">
            <summary>
            StartTime100ns for a code:TraceEvents is defined to be any time of the first event (or any time
            before it and after any event in the whole log that is before the first event in the
            TraceEvents).   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.ProcessIndex">
            <summary>
            We give each process a unique index from 0 to code:TraceProcesses.MaxProcessIndex. Thus it is unique
            within the whole code:TraceLog. You are explictly allowed take advantage of the fact that this number
            is in the range from 0 to code:TracesProcesses.MaxProcessIndex (you can create arrays indexed by
            code:ProcessIndex). We create the Enum because the strong typing avoids a class of user errors.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceProcesses">
            <summary>
            A code:TraceProcesses represents the list of procsses in the Event log.  
            
            TraceProcesses are IEnumerable, and will return the processes in order of time created.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcesses.System#Collections#Generic#IEnumerable{Diagnostics#Tracing#TraceProcess}#GetEnumerator">
            <summary>
            Enumerate all the threads that occured in the trace log.  It does so in order of their process
            offset events in the log.  
            </summary> 
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcesses.GetProcess(System.Int32,System.Int64)">
            <summary>
            Given a OS process ID and a time, return the last code:TraceProcess that has the same process ID,
            and whose offset start time is less than 'time100ns'. If 'time100ns' is during the threads lifetime this
            is guarenteed to be the correct process. Using time100ns = code:TraceLog.SessionEndTime100ns will return the
            last process with the given PID, even if it had died.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcesses.LastProcessWithID(System.Int32)">
            <summary>
            Return the last process in the log with the given process ID.  Useful when the logging session
            was stopped just after the processes completed (a common scenario).  
            </summary>
            <param name="processID"></param>
            <returns></returns>
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcesses.FirstProcessWithName(System.String,System.Int64)">
            <summary>
            Gets the first process (in time) that has the name 'processName' that started after 'afterTime'
            (inclusive). The name of a process is the file name (not full path), without its extension. Returns
            null on failure
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcesses.#ctor(Diagnostics.Tracing.TraceLog)">
            <summary>
            TraceProcesses represents the entire ETL moduleFile log.   At the node level it is organized by threads.  
            
            The TraceProcesses also is where we put various caches that are independent of the process involved. 
            These include a cache for code:TraceModuleFile that represent native images that can be loaded into a
            process, as well as the process lookup tables and a cache that remembers the last calls to
            GetNameForAddress(). 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcesses.Log">
            <summary>
            The log associated with this collection of threads. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcesses.MaxProcessIndex">
            <summary>
            The count of the number of code:TraceProcess s in the trace log. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcesses.Item(Diagnostics.Tracing.ProcessIndex)">
            <summary>
            Each process that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to code:BatchCount - 1.   Return the code:TraceProcess for the given index.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceProcess">
            <summary>
            A code:TraceProcess represents a process.  
            
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceProcess.#ctor(System.Int32,Diagnostics.Tracing.TraceLog,Diagnostics.Tracing.ProcessIndex)">
            <summary>
            Create a new code:TraceProcess.  It should only be done by code:log.CreateTraceProcess because
            only code:TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.ProcessID">
            <summary>
            The OS process ID associated with the process.   It is NOT unique across the whole log.  Use
            code:ProcessIndex for if you need that. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.ProcessIndex">
            <summary>
            The index into the logical array of code:TraceProcesses for this process.  Unlike ProcessID (which
            may be reused after the process dies, the process index is unique in the log. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.Log">
            <summary>
            The log file associated with the process. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.Threads">
            <summary>
            Enumerate all the threads that occured in this process.  
            </summary> 
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.Name">
            <summary>
            This is a short name for the process.  It is the image file name without the path or suffix.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.Is64Bit">
            <summary>
            Is the process a 64 bit process
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.EventsInProcess">
            <summary>
            Filters events to only those for a particular process. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceProcess.EventsDuringProcess">
            <summary>
            Filters events to only that occured during the time a the process was alive. 
            </summary>
            
        </member>
        <member name="T:Diagnostics.Tracing.ThreadIndex">
            <summary>
            We give each thread  a unique index from 0 to code:TraceThreads.MaxThreadIndex. Thus it is unique
            within the whole code:TraceLog. You are explictly allowed take advantage of the fact that this
            number is in the range from 0 to code:TracesThreads.MaxThreadIndex (you can create arrays indexed by
            code:ThreadIndex). We create the Enum because the strong typing avoids a class of user errors.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceThreads">
            <summary>
            A code:TraceThreads represents the list of threads in a process. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceThreads.System#Collections#Generic#IEnumerable{Diagnostics#Tracing#TraceThread}#GetEnumerator">
            <summary>
            Enumerate all the threads that occured in the trace log.  It does so in order of their thread
            offset events in the log.  
            </summary> 
        </member>
        <member name="M:Diagnostics.Tracing.TraceThreads.GetThread(System.Int32,System.Int64)">
            <summary>
            Given a OS thread ID and a time, return the last code:TraceThread that has the same thread index,
            and whose offset time is less than 'time100ns'. If 'time100ns' is during the threads lifetime this
            is guarenteed to be the correct thread. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceThreads.GetOrCreateThread(System.Int32,System.Int64,Diagnostics.Tracing.TraceProcess,System.Boolean)">
            <summary>
            Get the thread for threadID and time100ns.   Create if necessary.  If 'isThreadCreateEvent' is true, 
            then force  the creation of a new thread EVEN if the thread exist since we KNOW it is a new thread 
            (and somehow we missed the threadEnd event).   Process is the process associated with the thread.  
            It can be null if you really don't know the process ID.  We will try to fill it in on another event
            where we DO know the process id (ThreadEnd event).     
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceThreads.#ctor(Diagnostics.Tracing.TraceLog)">
            <summary>
            TraceThreads   represents the collection of threads in a process. 
            
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThreads.MaxThreadIndex">
            <summary>
            The count of the number of code:TraceThread s in the trace log. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThreads.Item(Diagnostics.Tracing.ThreadIndex)">
            <summary>
            Each thread that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to code:BatchCount - 1.   Return the code:TraceThread for the given index.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceThread">
            <summary>
            A code:TraceThread represents a tread of execution in a process.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceThread.#ctor(System.Int32,Diagnostics.Tracing.TraceProcess,Diagnostics.Tracing.ThreadIndex)">
            <summary>
            Create a new code:TraceProcess.  It should only be done by code:log.CreateTraceProcess because
            only code:TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.ThreadID">
            <summary>
            The OS process ID associated with the process. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.ThreadIndex">
            <summary>
            The index into the logical array of code:TraceThreads for this process.  Unlike ThreadId (which
            may be reused after the trhead dies, the T index is unique over the log.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.Process">
            <summary>
            The process associated with the thread. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.EventsInThread">
            <summary>
            Filters events to only those for a particular thread. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.EventsDuringThread">
            <summary>
            Filters events to only that occured during the time a the thread was alive. 
            </summary>
            
        </member>
        <member name="P:Diagnostics.Tracing.TraceThread.ThreadInfo">
            <summary>
            ThreadInfo is a string that tries to identify the thread symbolically.   e.g. .NET THreadpool, .NET GC 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLoadedModules">
            <summary>
            code:TraceLoadedModules represents the collection of static modules (loaded DLLs or EXEs that
            directly runnable) in a particular process.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLoadedModules.GetManagedModule(System.Int64,System.Int64)">
            <summary>
            Returns the managedModule with the given moduleID.  For native images the managedModule ID is the image base.  For
            managed images the managedModule returned is always the IL managedModule. 
            TODO should managedModuleID be given an opaque type?
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLoadedModules.GetModuleContainingAddress(System.UInt64,System.Int64)">
            <summary>
            This function will find the module assocated with 'address' at 'time100ns' however it will only
            find modules that are mapped in memory (module assocated with JIT compiled methods will not be found).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLoadedModules.GetLoadedModule(System.String,System.Int64)">
            <summary>
            Returns the module representing the unmanaged load of a file. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLoadedModules.FindManagedModuleAndIndex(System.Int64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an a given managed module ID.  If not found, new module
            should be inserated at index + 1;
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceLoadedModules.FindModuleAndIndexContainingAddress(System.UInt64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an address that lives within the image.  If the module
            did not match the new entry should go at index+1.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLoadedModule">
            <summary>
            A code:TraceLoadedModule represents a collection of code that is ready to run (it is loaded into a
            process. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLoadedModule.ImageBase">
            <summary>
            0 for managed modules without NGEN images.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLoadedModule.LoadTime">
            <summary>
            The load time is the time the LoadLibrary was done if it was loaded from a file, otherwise is the
            time the CLR loaded the module. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLoadedModule.ModuleFile">
            <summary>
            If this managedModule was a file that was mapped into memory (eg LoadLibary), then ModuleFile points at
            it.  If a managed module does not have a file associated with it, this can be null.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLoadedModule.ManagedModule">
            <summary>
            If this module is an NGEN (or IL) image, return the first instance that this module was loaded as a
            managed module (note that there may be more than one (if the code is Appdomain specific and loaded
            in several appdomains).  
            
            TODO: provide a way of getting at all the loaded images.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceManagedModule">
            <summary>
            A code:TraceManagedModule is a .NET runtime loaded managedModule.  
            TODO explain more
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceManagedModule.NativeModule">
            <summary>
            If the managed managedModule is an IL managedModule that has has an NGEN image, return it. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.CallStackIndex">
            <summary>
            code:CallStackIndex uniquely identifies a callstack within the log.  Valid values are between 0 and
            code:TraceCallStacks.CallStackIndexLimit, Thus an array can be used to 'attach' data to a callstack.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCallStacks.SetSize(System.Int32)">
            <summary>
            Used to 'undo' the effects of adding a eventToStack that you no longer want.  This happens when we find
            out that a eventToStack is actually got more callers in it (when a eventToStack is split).  
            </summary>
            <param name="origSize"></param>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCallStacks.GetRootForThread(Diagnostics.Tracing.ThreadIndex)">
            <summary>
            Returns an index that represents the 'theads' of the stack.  It encodes the thread which owns this stack into this. 
            We encode this as -ThreadIndex - 2 (since -1 is the Invalid node)
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceCallStack">
            <summary>
            A TraceCallStack is a structure that represents a call eventToStack as a linked list.  It contains the
            Address in the current frame, and the pointer to the caller's eventToStack.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.MethodIndex">
            <summary>
            code:MethodIndex uniquely identifies a method within the log.  Valid values are between 0 and
            code:TraceMethods.MaxMethodIndex, Thus an array can be used to 'attach' data to a method.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceMethod">
            <summary>
            A TraceMethod represents the symbolic information for a particular method.
            It does NOT know what process it lives in or what TraceLoadedModule it
            is loaded in, but DOES know what TraceModuleFile and source line that is
            associated with it
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceMethod.MethodToken">
            <summary>
            returns 0 for unmanged code or method not found. 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceMethod.MethodRva">
            <summary>
            Returns 0 for managed code or method not found;
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.CodeAddressIndex">
            <summary>
            code:CodeAddressIndex uniquely identifies a symbolic codeAddress within the log (note that the SAME
            physical addresses can have a different symbolic codeAddress because they are in different
            processes). Valid values are between 0 and code:TraceCodeAddresses.MaxCodeAddressIndex, Thus an array
            can be used to 'attach' data to a method.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.ILOffset(Diagnostics.Tracing.CodeAddressIndex)">
            <summary>
            returns -1 if the code address is not managed (or unknown). 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.GetSymbolReaderModule(Symbols.SymbolReader,Diagnostics.Tracing.TraceModuleFile)">
            <summary>
            Calls OpenModuleFile and caches the last entry
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceCodeAddresses.UnsafePDBMatching">
            <summary>
            Will look up PDBs without validating that the GUID is OK.   Pretty dangerous, don't use it if you avoid it.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.ForAllUnresolvedCodeAddressesInRange(System.UInt64,System.Int32,Diagnostics.Tracing.TraceProcess,Diagnostics.Tracing.TraceEvent,Diagnostics.Tracing.TraceCodeAddresses.ForAllCodeAddrAction)">
            <summary>
            Allows you to get a callback for each code address that is in the range from start to 
            start+length within the process 'process'.   It is legal to have process==0 if you supply 'context'
            (which is used to find the context).  This is useful because we only look up the process lazily
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.AddMethod(Diagnostics.Tracing.Parsers.MethodLoadUnloadVerboseTraceData)">
            <summary>
            Called when JIT CLR Rundown events are processed. It will look if there is any
            address that falls into the range of the JIT compiled method and if so log the
            symbolic information (otherwise we simply ignore it)
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.AddMethod(Diagnostics.Tracing.Parsers.MethodLoadUnloadJSTraceData,System.Collections.Generic.Dictionary{Diagnostics.Tracing.JavaScriptSourceKey,System.String})">
            <summary>
            Adss a JScript method 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.GetOrCreateCodeAddressIndex(Diagnostics.Tracing.TraceProcess,System.Int64,System.UInt64)">
            <summary>
            Gets the symbolic information entry for 'address' which can be any address.  If it falls in the
            range of a symbol, then that symbolic information is returned.  Regardless of whether symbolic
            information is found, however, an entry is created for it, so every unique address has an entry
            in this table.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.GetSortedCodeAddressIndexes">
            <summary>
            Sort from lowest address to highest address. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.LookupSymbols(Diagnostics.Tracing.TraceLogOptions)">
            <summary>
            Do symbol resolution for all addresses in the log file. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.OpenPdbForModuleFile(Symbols.SymbolReader,Diagnostics.Tracing.TraceModuleFile)">
            <summary>
            Tries to open the PDB for 'moduleFile'.  Returns null if unsuccessful. 
            TODO FIX NOW this belongs on a TraceModuleFile.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.GetClrDirectoryForNGenImage(System.String,System.IO.TextWriter)">
            <summary>
            Deduce the path to where CLR.dll (and in particular NGEN.exe live for the NGEN image 'ngenImagepath')
            Returns null if it can't be found
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.FindAndRemove(System.Int64,Diagnostics.Tracing.ProcessIndex,Diagnostics.Tracing.TraceCodeAddresses.ILMapIndex@)">
            <summary>
            Find the ILToNativeMap for 'methodId' in process associated with 'processIndex' 
            and then remove it from the table (this is what you want to do when the method is unloaded)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceCodeAddresses.codeAddressBuckets">
            <summary>
            Initialially we only have addresses and we need to group them into methods.   We do this by creating 64 byte 'buckets'
            see code:bucketSize which allow us to create a hash table.   Once we have grouped all the code addresses together into
            the smallest interesting units (e.g. methods), we don't need this table anymore.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceCodeAddresses.ManagedMethodRecordCount">
            <summary>
            Indicates the number of managed method records that were encountered.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceCodeAddresses.TotalCodeAddresses">
            <summary>
            The number of times a code address appears in the log.   Unlike MaxCodeAddressIndex, TotalCodeAddresses counts the same address
            in different places (even if in the same stack) as distinct.   
            
            The sum of ModuleFile.CodeAddressesInModule for all modules should sum to this number.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceCodeAddresses.CodeAddressBucketEntry">
            <summary>
            Code ranges need to be looked up by arbitrary address. There are two basic ways of doing this
            efficiently. First a binary search, second create 'buckets' (fixed sized ranges, see
            code:bucketSize and code:RoundToBucket) and round any address to these buckets and look them up
            in a hash table. This latter option is what we use. What this means is that when a entry is added
            to the table (see code:AddMethod) it must be added to every bucket over its range. Each entry in
            the table is a code:CodeAddressBucketEntry which is simply a linked list.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.CodeAddressInfo.GetProcessIndex(Diagnostics.Tracing.TraceCodeAddresses)">
            <summary>
            This is only valid until MethodIndex or ModuleFileIndex is set.   
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceCodeAddresses.CodeAddressInfo.GetMethodIndex(Diagnostics.Tracing.TraceCodeAddresses)">
            <summary>
            Only for managed code.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceCodeAddresses.CodeAddressInfo.ModuleFileIndex">
            <summary>
            Only for unmanaged code.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceCodeAddress">
            <summary>
            A TraceCodeAddress represents a address of code (where an instruction pointer might point). Unlike a
            raw pointer, TraceCodeAddresses will be distinct if they come from different ModuleFiles (thus at
            different times (or different processes) different modules were loaded and had the same virtual
            address they would NOT have the same TraceCodeAddress because the load file (and thus the symbolic
            information) would be different.
            
            TraceCodeAddresses hold the symbolic information associated with the address.
            
            TraceCodeAddress point at TraceMethod and TraceModuleFile.  None of these types know about the
            TraceLoadedModule (whic does keep track of when it gets loaded and unloaded), however they
            DO make certain that there is no confusion about the symbolic information (thus the same address
            in memory might point at completely different TraceMethod and TraceModuleFile because the
            code was unloaded and other code loaded between the two references.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceCodeAddress.ILOffset">
            <summary>
            This is only valid for managed methods returns -1 if invalid / unavailable
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceCodeAddress.ModuleName">
            <summary>
            ModuleName is the name of the file without path or extension. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceModuleFiles">
            <summary>
            Represents a collection of code:TraceModuleFile
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceModuleFiles.System#Collections#Generic#IEnumerable{Diagnostics#Tracing#TraceModuleFile}#GetEnumerator">
            <summary>
            Enumerate all the files that occured in the trace log.  
            </summary> 
        </member>
        <member name="M:Diagnostics.Tracing.TraceModuleFiles.GetModuleFile(System.String,System.UInt64)">
            <summary>
            For a given file name, get the code:TraceModuleFile associated with it.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.TraceModuleFiles.GetOrCreateModuleFile(System.String,System.UInt64)">
            <summary>
            We cache information about a native image load in a code:TraceModuleFile.  Retrieve or create a new
            cache entry associated with 'nativePath' and 'moduleImageBase'.  'moduleImageBase' can be 0 for managed assemblies
            that were not loaded with LoadLibrary.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceModuleFiles.MaxModuleFileIndex">
            <summary>
            Each file is given an index for quick lookup.   MaxModuleFileIndex is the
            maximum such index (thus you can create an array that is 1-1 with the
            files easily).  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceModuleFile">
            <summary>
            The TraceModuleFile represents a executable file that can be loaded into memory (either an EXE or a
            DLL).  It only represents the data file as well as the location in memory where it was loaded (or
            its ModuleID if it is a managed module), but NOT the load or unload time or the process.  Thus 
            it is good for shared symbolic information.    Also note that TraceModuleFiles are NOT guarenteed
            to be interned (that is there could be two entries that have the same exact file name).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceModuleFile.FilePath">
            <summary>
            The moduleFile name associted with the moduleFile.  May be the empty string if the moduleFile has no moduleFile
            (dynamically generated).  For managed code, this is the IL moduleFile name.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceModuleFile.Name">
            <summary>
            This is the short name of the moduleFile (moduleFile name without exention). 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceModuleFile.CodeAddressesInModule">
            <summary>
            The number of code addresses in this module.  This is useful for determining if 
            this module is worth having its symbolic information looked up or not.   
            
            This number is defined as the number of appearances this module has in any stack 
            or any event with a code addresss (If the modules appears 5 times in a stack that
            counts as 5 even though it is just one event's stack).  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceModuleFile.ManagedModule">
            <summary>
            If this is an NGEN image, return the TraceModuleFile of the IL image.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.TraceLogOptions">
            <summary>
            TraceLogOptions control the generation of a TraceLog.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.LocalSymbolsOnly">
            <summary>
            Resolving symbols from a symbol server can take a long time. If
            there is a DLL that always fails, it can be quite anoying because
            it will always cause delays, By specifying only local symbols it
            will only resolve the symbols if it can do so without delay.
            Symbols that have been reviously locally cached from a symbol
            server count as local symobls.
               
            TODO NOT IMPLEMENTED.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.SourceLineNumbers">
            <summary>
            If set, will resolve addresses to line numbers, not just names.  Default is not to have line
            numbers.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.SymbolDebug">
            <summary>
            print detailed symbolic information (TODO where?)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.AlwaysResolveSymbols">
            <summary>
            By default symbols are only resolve if there are stacks assocated with the trace. 
            Setting this option forces resolution even if there are no stacks. 
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.KeepAllEvents">
            <summary>
            Normally events that are only to convey non-temporal information (like DCStart end Ends, MethodName events, File name evens
            are removed from the stream.   However sometimes it is useful to keep these events (typically for deubgging TraceEvent itslef)
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.MaxEventCount">
            <summary>
            Sometimes you collect too much data, and you just want to look at a fraction of it to speed things up
            (or to keep file size under control).  This allows that.   10M will produce about 3-4GB 
            1M is a good value to keep things under control.  Note that we still scan the entire original ETL file
            because we look for rundown events, however we don't transerfer them to the ETLX file.  
            The default is 10M because ETLX has a restriction of 4GB in size.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.SkipMSec">
            <summary>
            If you have too much data and wish to skip the first part of the trace Set this to the number of msec to skip.
            The idea is that you might first look at the first 1M events, then set this to a number near the end of that first
            block to get the next block etc.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.OnLostEvents">
            <summary>
            If this delegate is non-null, it is called if there are any lost events.  
            It is passed the number of lost events.  You can throw if you want to abort.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.TraceLogOptions.ExplicitManifestDir">
            <summary>
            The directory to read files of the form *.manifest.xml to allow you to read unregistered providers.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.TraceLogOptions.ConversionLog">
            <summary>
            Writes status to this log.  Useful for debugging symbol issues.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.ETLXTraceEventSource">
            <summary>
            Represents a source for an ETLX file.  This is the class returned by the code:TraceEvents.GetSource
            methodIndex 
            </summary>
        </member>
        <member name="T:Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a 
            parapeter to the constuctor of a Command.  
            
            It is useful for these options be be on a separate class (rather than 
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise. 
            </summary>
        </member>
        <member name="F:Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options
            </summary>
            <returns>The copy of the command options</returns>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow propery and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout propery and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of 
            environmetn variables to be passed to the sub-process and returns the 
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero 
            exit code.  NoThrow suppresses this. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.  
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Elevate">
            <summary>
            Indicates that the command must run at elevated Windows privledges (causes a new command window)
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.  
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property 
            of the command.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="T:Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexitity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="M:Utilities.Command.RunToConsole(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine', sending the output to the console, and wait for the command to complete.
            This simulates what batch filedo when executing their commands.  It is a bit more verbose
            by default, however 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.Run(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command 
            structure. 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String,Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you 
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options. 
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be true on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal 
            Command.Run failure was the appropriate action.  
            </summary>
            <param name="message">An additional message to print in the throw (can be null)</param>
        </member>
        <member name="M:Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the 
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however. 
            </summary>
        </member>
        <member name="M:Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.  
            </summary>
        </member>
        <member name="M:Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.   
            Returns null if it was not found.   
            </summary>
        </member>
        <member name="P:Utilities.Command.StartTime">
            <summary>
            The time the process started.  
            </summary>
        </member>
        <member name="P:Utilities.Command.HasExited">
            <summary>
            returns true if the process has exited. 
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitTime">
            <summary>
            The time the processed Exited.  (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Duration">
            <summary>
            The duration of the command (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Id">
            <summary>
            The operating system ID for the subprocess.  
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitCode">
            <summary>
            The process exit code for the subprocess.  (HasExited should be true before calling)
            Often this does not need to be checked because Command.Run will throw an exception 
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property 
            was set.  
            </summary>
        </member>
        <member name="P:Utilities.Command.Output">
            <summary>
            The standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is 
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time. 
            </summary>
        </member>
        <member name="P:Utilities.Command.Options">
            <summary>
            Returns that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="P:Utilities.Command.Process">
            <summary>
            Get the underlying process object.  Generally not used. 
            </summary>
        </member>
        <member name="T:Utilities.DirectoryUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system directories. 
            </summary>
        </member>
        <member name="M:Utilities.DirectoryUtilities.Copy(System.String,System.String)">
            <summary>
            SafeCopy sourceDirectory to directoryToVersion recursively. The target directory does
            no need to exist
            </summary>
        </member>
        <member name="M:Utilities.DirectoryUtilities.Copy(System.String,System.String,System.IO.SearchOption)">
            <summary>
            SafeCopy all files from sourceDirectory to directoryToVersion.  If searchOptions == AllDirectories
            then the copy is recursive, otherwise it is just one level.  The target directory does not
            need to exist. 
            </summary>
        </member>
        <member name="M:Utilities.DirectoryUtilities.Clean(System.String)">
            <summary>
            Clean is sort of a 'safe' recursive delete of a directory.  It either deletes the
            files or moves them to '*.deleting' names.  It deletes directories that are completely
            empty.  Thus it will do a recursive delete when that is possible.  There will only 
            be *.deleting files after this returns.  It returns the number of files and directories
            that could not be deleted.  
            </summary>
        </member>
        <member name="M:Utilities.DirectoryUtilities.DeleteOldest(System.String,System.Int32)">
            <summary>
            Removes the oldest directories directly under 'directoryPath' so that 
            only 'numberToKeep' are left. 
            </summary>
            <param variable="directoryPath">Directory to removed old files from.</param>
            <param variable="numberToKeep">The number of files to keep.</param>
            <returns> true if there were no errors deleting files</returns>
        </member>
        <member name="M:Utilities.DirectoryUtilities.GetFiles(System.String,System.String,System.IO.SearchOption)">
             <summary>
             DirectoryUtilities.GetFiles is basicaly the same as Directory.GetFiles 
             however it returns IEnumerator, which means that it lazy.  This is very important 
             for large directory trees.  A searchPattern can be specified (Windows wildcard conventions)
             that can be used to filter the set of archiveFile names returned. 
             
             Suggested Usage
             
                 foreach(string fileName in DirectoryUtilities.GetFiles("c:\", "*.txt")){
                     Console.WriteLine(fileName);
                 }
            
             </summary>
             <param variable="directoryPath">The base directory to enumerate</param>
             <param variable="searchPattern">A pattern to filter the names (windows filename wildcards * ?)</param>
             <param variable="searchOptions">Indicate if the search is recursive or not.  </param>
             <returns>The enumerator for all archiveFile names in the directory (recursively). </returns>
        </member>
        <member name="T:FastSerialization.StreamLabel">
            <summary>
            A StreamLabel is a 32 bit integer that represents a position in a code:IStreamReader or
            code:IStreamWriter. During writing it is generated by the code:IStreamWriter.GetLabel methodIndex an
            consumed by the code:IStreamWriter.WriteLabel methodIndex. On reading you can use
            code:IStreamReader.Current and and code:IStreamReader. 
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamWriter">
            <summary>
            code:IStreamWriter is meant to be a very simple streaming protocol. You can write integral types,
            strings, and labels to the stream itself.  
            
            code:IStreamWrite can be thought of a simplified code:System.IO.BinaryWriter, or maybe the writer
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also code:IStreamReader
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamReader">
            code:IStreamReader is meant to be a very simple streaming protocol. You can read integral types,
            strings, and labels to the stream itself.  You can also goto labels you have read from the stream. 
            
            code:IStreamReader can be thought of a simplified code:System.IO.BinaryReder, or maybe the reader
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also code:IStreamWriter
        </member>
        <member name="M:FastSerialization.IStreamReader.GotoSuffixLabel">
            <summary>
            Sometimes information is only known after writting the entire stream.  This information can be put
            on the end of the stream, but there needs to be a way of finding it relative to the end, rather
            than from the begining.   A IStreamReader, however, does not actually let you go 'backwards' easily
            because it does not guarentee the size what it writes out (it might compress).  The solution is
            the concept of a 'suffixLabel' which is a StreamLabel that can be written as the last entry in
            the stream that IStreamReader knows how to read.  This can point at whatever information needs
            to go at the end of the stream.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.Version">
            <summary>
            This is the version represents the version of both the reading
            code and the version for the format for this type in serialized form.  
            See code:IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.MinimumReaderVersion">
            <summary>
            The version the the smallest (oldest) reader code that can read 
            this file format.  Readers strictly less than this are rejected.  
            This allows support for forward compatbility.   
            See code:IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="T:FastSerialization.Serializer">
            <summary>
            #SerializerIntroduction see also code:#StreamLayout
            
            The code:Serializer class is a general purpose object graph serializer helper. While it does not have
            any knowledge of the serialization format of individual object, it does impose conventions on how to
            serialize support information like the header (which holds verisioning information), a trailer (which
            holds defered pointer information), and how types are versioned. However these conventions are
            intended to be very generic and thus this class can be used for essentially any serialization need.
            
            Goals:
                * Allows full range of serialization, including subclassing and cyclic object graphs.
                * Can be serialized and deserialized efficiently sequentially (no seeks MANDATED on read or
                    write). This allows the serializer to be used over pipes and other non-seekable devices).
                * Pay for play (thus very efficient in simple cases (no subclassing or cyclic graphs).
                * Ideally self-describing, and debuggable (output as XML if desired?)
            
            Versioning:
                * We want the ability for new formats to accept old versions if objects wish to support old
                    formats
                * Also wish to allow new formats to be read by OLD version if the new format is just an
                    'extension' (data added to end of objects). This makes making new versions almost pain-free.
                    
            Concepts:
                * No-seek requirement
                
                    The serialized form should be such that it can be deseralized efficiently in a serial fasion
                    (no seeks). This means all information needed to deserialize has to be 'just in time' (can't
                    be some table at the end). Pragmatically this means that type information (needed to create
                    instances), has to be output on first use, so it is available for the deserializer.
                    
                * Laziness requirement
                
                    While is should be possible to read the serialized for sequentially, we should also not force
                    it. It should be possible to have a large file that represents a persisted stucture that can
                    be lazily brought into memory on demand. This means that all information needed to
                    deserialize must also be 'randomly available' and not depend on reading from the begining.
                    Pragmatically this means that type information, and forward forwardReference information needs to
                    have a table in a well known Location at the end so that it can be found without having to
                    search the file sequentially.
                
                * Versioning requirement
                    
                    To allow OLD code to access NEW formats, it must be the case that the serialized form of
                    every instance knows how to 'skip' past any new data (even if it does not know its exact
                    size). To support this, objects have 'begin' and 'end' tags, which allows the deserializer to
                    skip the next object.
                    
                * Polymorphsim requirement
                
                    Because the user of a filed may not know the exact instance stored there, in general objects
                    need to store the exact type of the instance. Thus they need to store a type identifer, this
                    can be folded into the 'begin' tag.
                    
                * Arbitrary object graph (cicularity) requirement (Forward references)
                
                    The serializer needs to be able to serialize arbirary object graphs, including those with
                    cycles in them. While you can do this without forward references, the system is more flexible
                    if it has the concept of a forward refernce. Thus whenever a object refernece is required, a
                    'forward forwardReference' can be given instead. What gets serialized is simply an unique forward
                    refernece index (index into an array), and at some later time that index is given its true
                    value. This can either happen with the target object is serialied (see
                    code:Serializer.Tags.ForwardDefintion) or at the end of the serialization in a forward
                    refernece table (which allows forward references to be resolved without scanning then entire
                    file.
                    
                * Contract between objects code:IFastSerializable.ToStream:
                
                    The heart of the serialization and deserialization process s the code:IFastSerializable
                    interface, which implements just two methods: ToStream (for serializing an object), and
                    FromStream (for deserializing and object). This intefaces is the mechanism by which objects
                    tell the serializer what data to store for an individual instance. However this core is not
                    enough. An object that implements code:IFastSerializable must also implement a default
                    constructor (constructor with no args), so that that deserializer can create the object (and
                    then call FromStream to populated it).
                    
                    The ToStream methodIndex is only responsible for serializing the data in the object, and by itself
                    is not sufficient to serialize an interconnected, polymoriphic graph of objects. It needs
                    help from the code:Serializer and code:Deserialize to do this. code:Serializer takes on the
                    responsibility to deal with persisting type information (so that code:Deserialize can create
                    the correct type before code:IFastSerializable.FromStream is called). It is also the
                    serializer's responsibilty to provide the mechanism for dealing with circular object graphs
                    and forward references.
                
                * Layout of a serialized object: A serialized object has the following basic format
                
                    * If the object is the defintion of a previous forward references, then the defintion must
                        begin with a code:Serializer.Tags.ForwardDefintion tag followed by a forward forwardReference
                        index which is being defined.
                    * code:Serializer.Tags.BeginObject tag
                    * A reference to the code:SerializationType for the object. This refernece CANNOT be a
                        forward forwardReference because its value is needed during the deserialization process before
                        forward references are resolved.
                    * All the data that that objects 'code:IFastSerializable.ToStream methodIndex wrote. This is the
                        heart of the deserialized data, and the object itself has a lot of control over this
                        format.
                    * code:Serializer.Tags.EndObject tag. This marks the end of the object. It quickly finds bugs
                        in ToStream FromStream mismatches, and also allows for V1 deserializers to skip past
                        additional fields added since V1.
                    
                * Serializing Object references:
                  When an object forwardReference is serialized, any of the following may follow in the stream
                  
                    * code:Serializer.Tags.NullReference used to encode a null object forwardReference.
                    * code:Serializer.Tags.BeginObject or code:Serializer.Tags.ForwardDefintion, which indicates
                        that this the first time the target object has been referenced, and the target is being
                        serialized on the spot.
                    * code:Serializer.Tags.ObjectReference which indicates that the target object has already
                        been serialized and what follows is the StreamLabel of where the definition is.
                    * code:Serializer.Tags.ForwardReference followed by a new forward forwardReference index. This
                        indicates that the object is not yet serialized, but the serializer has choosen not to
                        immediately serialize the object. Ultimately this object will be defined, but has not
                        happened yet.
                       
                * Serializing Types:
                  Types are simply objects of type code:SerializationType which contain enough information about
                  the type for the Deserializer to do its work (it full name and version number).   They are
                  serialized just like all other types.  The only thing special about it is that references to
                  types after the BeginObject tag must not be forward references.  
             
            #StreamLayout:
                The structure of the file as a whole is simply a list of objects.  The first and last objects in
                the file are part of the serialization infratructure.  
                
            Layout Synopsis
                * Signature representing code:Serializer format
                * EntryObject (most of the rest of the file)
                    * BeginObject tag
                    * Type for This object (which is a object of type code:SerializationType)
                        * BeginObject tag
                        * Type for code:SerializationType  POSITION1
                            * BeginObject tag
                            * Type for code:SerializationType
                                 * ObjectReference tag           // This is how our recursion ends.  
                                 * StreamLabel for POSITION1
                            * Version Field for SerializationType
                            * Miniumum Version Field for SerializationType
                            * FullName string for SerializationType                
                            * EndObject tag
                        * Version field for EntryObject's type
                        * Miniumum Version field for EntryObject's type
                        * FullName string for EntryObject's type
                        * EndObject tag
                    * Field1  
                    * Field2 
                    * V2_Field (this should be tagged so that it can be skipped by V1 deserializers.  
                    * EndObject tag
                * ForwardReferenceTable pseudo-object
                    * Count of forward references
                    * StreamLabel for forward ref 0
                    * StreamLabel for forward ref 1.
                    * ...
                * SerializationTrailer pseduo-object
                    * StreamLabel ForwardReferenceTable
                * StreamLabel to SerializationTrailer
                * End of stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.String,FastSerialization.IFastSerializable)">
            <summary>
            Open a serializer to a file (for persistance). 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.IFastSerializable)">
            <summary>
            If the object is potentially aliased (multiple references to it), you should write it with this methodIndex.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteDefered(FastSerialization.IFastSerializable)">
            <summary>
            To tune working set (or disk seeks), or to make the dump of the format more readable, it is
            valueable to have control over which of several references to an object will actually cause it to
            be serialized (by default the first encountered does it).
            
            WriteDeferedReference allows you to write just a forwardReference to an object with the expectation that
            somewhere later in the serialization process the object will be serialized. If no call to
            WriteObject() occurs, then the object is serialized automatically before the stream is closed
            (thus dangling references are impossible).        
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WritePrivate(FastSerialization.IFastSerializable)">
            <summary>
            This is an optimized version of code:WriteObjectReference that can be used in some cases.
            
            If the object is not aliased (it has an 'owner' and only that owner has references to it (which
            implies its lifetime is strictly less than its owners), then the serialzation system does not
            need to put the object in the 'interning' table. This saves a space (entries in the intern table
            as well as 'SyncEntry' overhead of creating hash codes for object) as well as time (to create
            that bookkeeping) for each object that is treated as private (which can add up if because it is
            common that many objects are private).  The private instances are also marked in the serialized
            format so on reading there is a simmilar bookeeping savings. 
            
            The ultimate bits written by code:WritePrivateObject are the same as code:WriteObject.
            
            TODO Need a DEBUG mode where we detect if others besides the owner refernence the object.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Close">
            <summary>
            Completes the writing of the stream. 
            </summary>
        </member>
        <member name="P:FastSerialization.Serializer.Writer">
            <summary>
            Retrieve the underlying stream we are writing to.  Generally the Write* methods are enough. 
            </summary>
        </member>
        <member name="T:FastSerialization.Deserializer">
            <summary>
            code:Deserializer is a helper class that holds all the information needed to deserialize an object
            graph as a whole (things like the table of objects already deserialized, and the list of types in
            the object graph.  
            
            see code:#SerializerIntroduction for more
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryTypeName">
            <summary>
            Returns the full name of the type of the entry object without actually creating it.
            Will return null on failure.  
            </summary>  
        </member>
        <member name="F:FastSerialization.Deserializer.deferForwardReferences">
            <summary>
            When we encounter a forward reference, we can either go to the forward reference table immediately and resolve it 
            (deferForwardReferences == false), or simply remember that that position needs to be fixed up and continue with
            the deserialization.   This later approach allows 'no seek' deserialization.   This variable which scheme we do. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.AllowLazyDeserialization">
            <summary>
            On by default.  If off, then you read the whole file from begining to the end and never have to
            seek.  This should only be used when you have this requirement (you are reading from an unseekable
            stream 
            
            TODO remove? we have not tested as tall with AllowLazyDeserialzation==false. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.VersionBeingRead">
            <summary>
            Meant to be called from FromStream.  It returns the version number of the 
            type being deserialized.   It can be used so that new code can recognises that it
            is reading an old file format and adjust what it reads.   
            </summary>
        </member>
        <member name="T:FastSerialization.DeferedRegion">
            <summary>
            #DeferedRegionOverview. 
            
            A DeferedRegion help make 'lazy' objects. You will have a DeferedRegion for each block of object you
            wish to independently decide whether to deserialize lazily (typically you have on per object however
            in the limit you can have one per field, it is up to you).
            
            When you call code:DeferedRegion.Write you give it a delegate that will write all the defered fields.
            The Write operation will place a forward reference in the stream that skips all the fields written,
            then the fields themselves, then define the forward reference. This allows readers to skip the
            defered fields.
            
            When you call code:DeferedRegion.Read  you also give it a delegate that reads all the defered fields.
            However when 'Read' instead of reading the fields it
            
                * remembers the deseializer, stream position, and reading delegate.
                * it uses the forward refernece to skip the region.
                
            When code:DeferedRegion.FinishRead is called, it first checks if the region was already restored. 
            If not it used the information to read in the defered region and returns.  Thus this FinishRead
            should be called before any deferred field is used.  
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Write(FastSerialization.Serializer,System.Action)">
            <summary>
            see code:#DeferedRegionOverview.  
            TODO more 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Read(FastSerialization.Deserializer,System.Action)">
            <summary>
            see code:#DeferedRegionOverview.  
            fromStream can be null, if FinishRead is never used.  
            TODO more 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.FinishReadHelper">
            <summary>
            This helper is just here to insure that FinishRead gets inlined 
            </summary>
        </member>
        <member name="T:Utilities.FileUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system files. 
            </summary>
        </member>
        <member name="M:Utilities.FileUtilities.ReadAllLines(System.String)">
            <summary>
            GetLines works much like File.ReadAllLines, however instead of returning a
            array of lines, it returns a IEnumerable so that the archiveFile is not read all
            at once.  This allows 'foreach' syntax to be used on very large files.  
            
            Suggested Usage
            
                foreach(string lineNumber in FileUtilities.GetLines("largeFile.txt")){
                    Console.WriteLine(lineNumber);
                }
            </summary>
            <param variable="fileName">The base directory to enumerate.</param>
            <returns>The enumerator for all lines in the archiveFile.</returns>
        </member>
        <member name="M:Utilities.FileUtilities.ExpandWildcards(System.String[],System.IO.SearchOption)">
            <summary>
            Given archiveFile specifications possibly with wildcards in them
            return an enumerator that returns each expanded archiveFile name in turn. 
            
            If searchOpt is AllDirectories it does a recursive match. 
            </summary>
        </member>
        <member name="M:Utilities.FileUtilities.ForceDelete(System.String)">
            <summary>
            Delete works much like File.Delete, except that it will succeed if the
            archiveFile does not exist, and will rename the archiveFile so that even if the archiveFile 
            is locked the original archiveFile variable will be made available.  
            
            It renames the  archiveFile with a '[num].deleting'.  These files might be left 
            behind.  
            
            It returns true if it was competely successful.  If there is a *.deleting
            archiveFile left behind, it returns false. 
            </summary>
            <param variable="fileName">The variable of the archiveFile to delete</param>
        </member>
        <member name="M:Utilities.FileUtilities.TryDelete(System.String)">
            <summary>
            Try to delete 'fileName' catching any exception.  Returns true if successful.   It will delete read-only files.  
            </summary>  
        </member>
        <member name="M:Utilities.FileUtilities.ForceCopy(System.String,System.String)">
            <summary>
            SafeCopy sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Utilities.FileUtilities.ForceMove(System.String,System.String)">
            <summary>
            Moves sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1">
            <summary>
            A cheap version of List(T). The idea is to make it as cheap as if you did it 'by hand' using an array and
            a int which represents the logical charCount. It is a struct to avoid an extra pointer dereference, so this
            is really meant to be embeded in other structures.
            
            Also made the Binary search is actually useful (by allowing the key to be something besides the element
            itself).
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Add(`0)">
            <summary>
            Add an item at the end of the array, growing as necessary. 
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Insert(System.Int32,`0)">
            <summary>
            Insert 'item' directly at 'index', shifting all items >= index up.  'index' can be code:Count in
            which case the item is appended to the end.  Larger indexes are not allowed. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Trim(System.Int32)">
            <summary>
            Trims the size of the array so that no more than 'maxWaste' slots are wasted.   Useful when
            you know that the array has stopped growing.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.BinarySearch``1(``0,System.Int32@,System.Collections.Generic.GrowableArray{`0}.Comparison{``0})">
            <summary>
            Sets 'index' to the the smallest index such that all elements with index > 'idx' are > key.  If
            index does not match any elements a new element should always be placed AFTER index.  Note that this
            means that index may be -1 if the new element belongs in the first position.  
            
            return true if the return index matched exactly (success)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Search``1(``0,System.Int32,System.Collections.Generic.GrowableArray{`0}.Comparison{``0},System.Int32@)">
            <summary>
            Perform a linear search starting at 'startIndex'.  If found return true and the index in 'index'.
            It is legal that 'startIndex' is greater than the charCount, in which case, the search returns false
            immediately.   This allows a nice loop to find all items matching a pattern. 
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.UnderlyingArray">
            <summary>
            Returns the underlying array.  Should not be used most of the time!
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1.Comparison`1">
            <summary>
            Should return -1 if x is less than elem.  
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamReader">
            <summary>
            A MemoryStreamReader is an implementation of the IStreamReader interface that works over a given byte[] array.  
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamWriter">
            <summary>
            A StreamWriter is an implementation of the IStreamWriter interface that generates a byte[] array. 
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamWriter">
            <summary>
            A IOStreamStreamWriter hooks a MemoryStreamWriter up to an output System.IO.Stream
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamWriter.RawStream">
            <summary>
            You should avoid using this if at all possible.  
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamReader">
            <summary>
            A IOStreamStreamReader hooks a MemoryStreamReader up to an input System.IO.Stream.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Fill(System.Int32)">
            <summary>
            Fill the buffer, making sure at least 'minimum' byte are available to read.  Throw an exception
            if there are not that many bytes.  
            </summary>
            <param name="minimum"></param>
        </member>
        <member name="M:Utilities.StreamUtilities.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            CopyStream simply copies 'fromStream' to 'toStream'
            </summary>
        </member>
        <member name="T:Utilities.XmlUtilities">
            <summary>
            The important thing about these general utilities is that they have only dependencies on mscorlib and
            System (they can be used from anywhere).  
            </summary>
        </member>
        <member name="T:Utilities.HistoryDictionary`1">
            <summary>
            A HistoryDictionary is designed to look up 'handles' (pointer sized quantities), that might get reused
            over time (eg Process IDs, thread IDs).  Thus it takes a handle AND A TIME, and finds the value
            associated with that handle at that time.   
            </summary>
        </member>
        <member name="M:Utilities.HistoryDictionary`1.Add(System.UInt64,System.Int64,`0,System.Boolean)">
            <summary>
            Adds the association taht 'id' has the value 'value' from 'startTime100ns' ONWARD until
            it is superseed by the same id being added with a time that is after this.   Thus if
            I did Add(58, 1000, MyValue1), and add(58, 500, MyValue2) 'TryGetValue(58, 750, out val) will return
            MyValue2 (since that value is 'in force' between time 500 and 1000.   
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.Parsers.WppTraceEventParser">
            <summary>
            This parser knows how to decode Windows Software Trace Preprocessor (WPP) events.  In order to decode
            the events it needs access to the TMF files that describe the events (these are created from the PDB at 
            build time. 
            
            Mostly what you use this for is the 'FormattedMessage' property of the event.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.Parsers.WppTraceEventParser.#ctor(Diagnostics.Tracing.TraceEventSource)">
            <summary>
            This one is for TraceLog deserialization
            </summary>
        </member>
    </members>
</doc>
